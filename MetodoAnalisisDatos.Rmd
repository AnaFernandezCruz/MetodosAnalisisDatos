---
title: "Métodos de Análisis de Datos"
author: "Ana Fernández Cruz, Jesús Gallego Olivas y Miguel Ángel Sánchez Alcázar."
date: "19 de Diciembre de 2019"
output: 
  html_document:
    code_folding: hide
---

```{r load_libraries, message=FALSE, warning=FALSE, echo=FALSE}

library(readr)
library(dplyr)
library(tidyverse)
library(DataExplorer)
library(skimr)
library(pander)
library(VIM)
library(ggplot2)
library(caret)
library(MASS)
library(forcats)
library(ggpubr)
library(corrr)
library(moments)

seed <- 456

```

```{r load_functions, message=FALSE, warning=FALSE, echo=FALSE}

# Funcion que divide un dataframe en dos grupos, el primero con un % que indiques por la variable per. El resto % en el segundo grupo.

split_dataframe <- function(df, per){
  set.seed(seed) 
  split <- sample(nrow(df), nrow(df) * per)
  return(list(df[split,], df[-split,]))
}

```

## Objectivos

En este informe se detalla el estudio realizado sobre un dataset que recoge información relevante de las viviendas en la ciudad de Agnes, en Iowa (Estados Unidos).  El estudio, intentara mediante un modelo de regresión lineal múltiple, **predecir el valor de la vivienda** en función de un gran número de variables (tanto continuas como categóricas) que describen prácticamente todos los aspectos que .

Para el control de versiones utilizaremos github. El repositorio se encuentra en https://github.com/AnaFernandezCruz/MetodosAnalisisDatos .

Antes de empezar a realizar el estudio debemos unificar los datos. Inicialmente los disponemos en tres archivos csv, 'train.csv', 'test.csv' y 'sample_submission.csv'.

```{r ready_files, message=FALSE, warning=FALSE, echo=FALSE}

# Cargamos los tres archivos
train_kaggle_ok <- read_csv('./Dataset/train.csv')
test_kaggle <- read_csv('./Dataset/test.csv')
test_kaggle_pk <- read_csv('./Dataset/sample_submission.csv')

# Merge el dataset test y sample_submission, ahora tendremos un dataset completo
test_kaggle_ok <- merge(test_kaggle, test_kaggle_pk, by="Id")

# Unificamos los dos dataset train.csv y test.csv
full_dataset <- rbind(train_kaggle_ok, test_kaggle_ok)

```

Despues de unirlos bajo un solo dataset, lo separemos de manera aleatoria en dos grupos. El primer grupo sera el 10% del total y lo utilizaremos como validación. Este dataset lo utilizaremos al final del estudio para comprobar como funciona nuestro modelo. El resto de los datos, el 90% faltante, lo utilizaremos para training y testing.

```{r validation_dataset, message=FALSE, warning=FALSE, echo=FALSE}

#Dividimos el dataset 10% - 90%
list_split <- full_dataset %>% split_dataframe(.1)

validation <- list_split[[1]]  # 10%
dataset <- list_split[[2]]     # 90%

#Guardamos el dataset de validacion en un archivo csv
write.csv(validation, './validation.csv', row.names=F)
  
```

---------------------------------------------------------------------------------------

## Análisis exploratorio inicial de los datos (EDA)

Realizaremos un primer resumen del estado del dataset:

```{r message=FALSE, warning=FALSE}

introduce(dataset)

```

Vemos que el dataset está dividido en:

* 81 variables distintas, en las que una de ellas es la clave principal (denominada Id) que no debermos tener en cuenta en el análisis de regresión. De estas variables, 43 son discretas y 38 contínuas. Vemos también que hay una gran cantidad de "missings" y el valor de "complete_row" es cero, lo que indica que ha habido algún problema con la lectura del dataset en algunas columnas.

Realizaremos un gráfico mirando la distribución de los datos por tipos y otra información que la anterior tabla ya incluía:

```{r message=FALSE, warning=FALSE}

plot_intro(dataset)

```

Como hemos indicado antes, vemos que este gráfico muestra en los valores de "complete rows" un valor del 0%, lo cuál parece indicar un problema con alguna columna en particular. Lo que observamos es que el valor NA es un valor de algunas de las columnas válido, con lo que habría que corregir esto para estas columnas y volver a hacer el análisis. Supondremos que para estas columnas no existe ningún valor genuinamente en blanco:

**Alley:** NA-No alley access, **BsmtQual:** NA-No Basement, **BsmtCond:** NA-No Basement, **BsmtExposure:** NA-No Basement, **BsmtFinType1:** NA-No Basement, **BsmtFinType2:** NA-No Basement, **GarageType:** NA-No Garage, **GarageFinish:** NA-No Garage, **GarageQual:** NA-No Garage, **GarageCond:** NA-No Garage, **PoolQC:** NA-No Pool, **Fence:** NA-No Fence, **MiscFeature:**NA-None
 
El siguiente código realiza la transformación anterior:
   
```{r keep_integrity, message=FALSE, warning=FALSE}

cols_remove_nas <-c('Alley','BsmtQual','BsmtCond','BsmtExposure','BsmtFinType1','BsmtFinType2','GarageType','GarageFinish','GarageQual','GarageCond','PoolQC','Fence','MiscFeature','FireplaceQu')

dataset <- mutate_at(dataset, cols_remove_nas, 
          list(~ifelse(is.na(.), 'NA',.)) )
```


```{r train_test, message=FALSE, warning=FALSE}

#Dividimos el dataset 70% - 30%
list_split <- dataset %>% split_dataframe(.7)

train <- list_split[[1]]  # 70%
test <- list_split[[2]]     # 30%

```

------------------------------------------------------------------

```{r message=FALSE, warning=FALSE, echo=FALSE}

#pathDatos = './Dataset/'
#pathLocal = './'
#fileTrain = paste(pathDatos,"train.csv",sep="", collapse = NULL)
#fileTest = paste(pathDatos,"test.csv",sep="", collapse = NULL)
#fileDatosPK = paste(pathDatos,"sample_submission.csv",sep="", collapse = NULL)
#fileDatosTrainTest = paste(pathLocal,"train_test.csv",sep="", collapse = NULL)
#fileDatosValidacion = paste(pathLocal,"validacion.csv",sep="", collapse = NULL)

borra_columnas_muchos_faltantes = FALSE
borra_columnas_incomodas = FALSE
columnas_borrar_faltantes <- c('FireplaceQu','Fence','Alley','MiscFeature','PoolQC','GarageType','GarageCond','GarageQual','GarageFinish','GarageYrBit','LoftFrontage')
columnas_borrar_incomodas <- c('BsmtFinType1','LowQualFinSF','MasVnrArea','BsmtHalfBath','EnclosedPorch','KitchenAbvGr','MiscVal','PoolArea','ScreenPorch','Utilities','Condition2','RoofMalt','Heating','Street')

#train_kaggle <- read_csv(fileTrain)
 #   head(train_kaggle)
    
  #  test_kaggle <- read_csv(fileTest)
   # head(test_kaggle)
    
    #claves_primarias <- read_csv(fileDatosPK)
    #head(claves_primarias)
    
    #Mergeamos el archivo de train y test ya que tienen las mismas columnas.
    
    #test_kaggle <- dplyr::inner_join(x=test_kaggle,y=claves_primarias,by = c('Id','Id'))   
    #full_dataset <- dplyr::union(train_kaggle, test_kaggle)
    #full_dataset_completo <- dplyr::union(train_kaggle, test_kaggle)
    #head(full_dataset)
    
    
    
    ## Completamos test con la columna que falta
    #total_test <- merge(test_kaggle,claves_primarias,by="Id")
    
    # Unimos train y test completo
    #full_dataset <- rbind(train_kaggle,total_test)
    
    ## Desordenamos todo el dataset
    #set.seed(42)
    #rows <- sample(nrow(full_dataset))
    #full_dataset <- full_dataset[rows, ]

    
    ## Conseguimos el 10% para validacion
    #split_validacion <-sort(sample(nrow(full_dataset), nrow(full_dataset)*.1))

    

    #if(borra_columnas_muchos_faltantes) {
    
      #full_dataset = subset( full_dataset, select = -columnas_borrar_faltantes)
     # full_dataset <- full_dataset %>% dplyr::select(-one_of(columnas_borrar_faltantes))
    
  #  }
  
   # if(borra_columnas_incomodas) {
      #full_dataset = subset( full_dataset, select = -columnas_borrar_faltantes)
    #  full_dataset <- full_dataset %>% select(-one_of(columnas_borrar_incomodas))
    #}
    
    #validacion <-full_dataset[split_validacion, ]
    #if(!file.exists(fileDatosTrainTest)) {
     # write.csv(validacion, fileDatosValidacion,row.names=F)
    #}
    
    #train_test<-full_dataset[-split_validacion,]
    #if(!file.exists(fileDatosTrainTest)) {
     # write.csv(train_test, fileDatosTrainTest,row.names=F)
    #}
  


#train_test <- read_csv(fileDatosTrainTest)
#set.seed(55)
#dt = sort(sample(nrow(train_test), nrow(train_test)*.7))
#train<-train_test[dt,]
#test<-train_test[-dt,]

```

Las variables que nos encontraremos en el dataset son las siguientes:

**MSSubClass:** La clase de construcción
**MSZoning:** La clasificación general de zonificación
**LotFrontage:** Pies lineales de calle conectados a la propiedad
**LotArea:** Tamaño del solar donde se asienta la casa en pies cuadrados
**Street:** Tipo de acceso por carretera a la propiedad
**Alley:** Tipo de acceso por callejón a la propiedad
**LotShape:** Forma general de propiedad
**LandContour:** Nivelado del terreno en el que se asienta propiedad
**Utilities:**  Tipo de utilidades(servicios) disponibles
**LotConfig:** Tipo de solar donde se asienta la propiead
**LandSlope:** Pendiente de la propiedad
**Neighborhood:** Ubicaciones físicas dentro de los límites de la ciudad de Ames
**Condition1:** Proximidad a la carretera principal o ferrocarril
**Condition2:** Proximidad a la carretera principal o al ferrocarril (si hay un segundo)
**BldgType:** Tipo de vivienda
**HouseStyle:** Estilo de vivienda
**OverallQual:** Material general y calidad de acabado
**OverallCond:** Calificación de condición general
**YearBuilt:** Fecha de construcción original
**YearRemodAdd:** Fecha de remodelación
**RoofStyle:** Tipo de techo
**RoofMatl:** Material del techo
**Exterior1st:** Cubierta exterior en la casa
**Exterior2nd:** Revestimiento exterior de la casa (si hay más de un material)
**MasVnrType:** Tipo de chapa de albañilería
**MasVnrArea:** Área de revestimiento de mampostería en pies cuadrados
**ExterQual:** Calidad del material exterior
**ExterCond:** Condición actual del material en el exterior.
**Foundation:** Tipo de cimiento
**BsmtQual:** Altura del sótano
**BsmtCond:** Estado general del sótano
**BsmtExposure:** Paredes de sótano a nivel de jardín o de salida
**BsmtFinType1:** Calidad del área terminada del sótano
**BsmtFinSF1:** Tipo 1 terminado pies cuadrados del sótano
**BsmtFinType2:** Calidad de la segunda área terminada (si está presente)
**BsmtFinSF2:** Pies cuadrados terminados tipo 2 del sótano
**BsmtUnfSF:** Pies cuadrados inacabados de área de sótano
**TotalBsmtSF:** Pies cuadrados totales del área del sótano
**Heating:** Tipo de calefacción
**HeatingQC:** Calidad y condición de calefacción
**CentralAir:** Aire acondicionado central
**Electrical:** Sistema eléctrico
**1stFlrSF:** Pies cuadrados del primer piso
**2ndFlrSF:** Pies cuadrados del segundo piso
**LowQualFinSF:** Pies cuadrados terminados de baja calidad (todos los pisos)
**GrLivArea:** Superficie habitable por encima del nivel del suelo (pies cuadrados)
**BsmtFullBath:** Baños completos en el sótano
**BsmtHalfBath:** Medio baño en el sótano
**FullBath:** Baños completos por encima del grado
**HalfBath:** Medio baño por encima del grado
**Bedroom:** Número de dormitorios por encima del nivel del sótano
**Kitchen:** Número de cocinas
**KitchenQual:** Calidad de cocina
**TotRmsAbvGrd:** Total de habitaciones por encima del grado (no incluye baños)
**Functional:** Calificación de funcionalidad doméstica 
**Fireplaces:** Número de chimeneas
**FireplaceQu:** Calidad de chimenea
**GarageType:** Ubicación del garaje dentro de la propiedad
**GarageYrBlt:** Año en que se construyó el garaje
**GarageFinish:** Acabado interior del garaje
**GarageCars:** Tamaño del garaje utilizable por automóviles
**GarageArea:** Tamaño del garaje en pies cuadrados
**GarageQual:** Calidad de garaje
**GarageCond:** Condición del garaje
**PavedDrive:** Entrada pavimentada
**WoodDeckSF:** Área de cubierta de madera en pies cuadrados
**OpenPorchSF:** Área de porche abierto en pies cuadrados
**Porche cerrado:** Área de porche cerrado en pies cuadrados
**EnclosedPorch:** Área de porche de tres estaciones en pies cuadrados
**ScreenPorch:** Área del porche de la pantalla en pies cuadrados
**PoolArea:** Área de la piscina en pies cuadrados
**PoolQC:** Calidad de la piscina
**Fence:** Calidad de la cerca
**MiscFeature:** Características varias no cubiertas en otras categorías
**MiscVal:** Valor de la característica miscelánea
**MoSold:** Mes vendido
**YrSold:** Año vendido
**SaleType:** Tipo de venta
**SaleCondition:** Condición de venta

A continuación, dividiremos las variables en las siguientes categorías:
* Variables con dominio contínuo y numérico
* Variable con dominio numérico discreto
* Variables descriptivas nominales (variables que toman valores alfanumérido de un conjunto finito de valores)
* Variables descriptivas ordinales (variables que contienen una relación de orden)

El siguiente código realiza la descomposición en dichas categorías para usar con posterioridad:

```{r}

var_discretas <- c('BsmtFullBath','BsmtHalfBath','FullBath','HalfBath','BedroomAbvGr','KitchenAbvGr','TotRmsAbvGrd','Fireplaces','GarageCars','GarageYrBlt','YearBuilt','YearRemodAdd','YrSold','MoSold')

var_continuas <- c('LotFrontage','LotArea','MasVnrArea','BsmtFinSF1','BsmtFinSF2','BsmtUnfSF','TotalBsmtSF','1stFlrSF','2ndFlrSF','LowQualFinSF','GrLivArea','GarageArea','WoodDeckSF','OpenPorchSF','EnclosedPorch', '3SsnPorch','ScreenPorch','PoolArea','MiscVal','SalePrice')

var_continuas_sin_columnas_imputacion <- c('LotFrontage','LotArea','MasVnrArea','BsmtFinSF1','BsmtFinSF2','BsmtUnfSF','TotalBsmtSF','1stFlrSF','2ndFlrSF','LowQualFinSF','GrLivArea','GarageArea','WoodDeckSF','OpenPorchSF','EnclosedPorch', '3SsnPorch','ScreenPorch','PoolArea','MiscVal','SalePrice')


var_ordinales <- c('LotShape','Utilities','LandSlope','OverallQual','OverallCond','ExterQual','ExterCond','BsmtQual','BsmtCond','BsmtExposure','BsmtFinType1','BsmtFinType2','HeatingQC','CentralAir','Electrical','KitchenQual','Functional','FireplaceQu','GarageFinish','GarageQual','GarageCond','PavedDrive','PoolQC','Fence')

var_nominales <- c('MSSubClass','MSZoning','Street','Alley','LandContour','LotConfig','Neighborhood','Condition1','Condition2','BldgType','HouseStyle','RoofStyle','RoofMatl','Exterior1st',
'Exterior2nd','MasVnrType','Foundation','Heating','GarageType','MiscFeature', 'SaleType','SaleCondition')

var_continuas_discretas = c(var_continuas,var_discretas)
var_continuas_discretas_sin_imputacion = c(var_continuas_sin_columnas_imputacion,var_discretas)

var_modelo = c()
var_columnas_eliminadas = c()
var_transformacion_log = c()
var_eliminar_correlacion = c()
var_creadas_transformacion = c()


```



```{r message=FALSE, warning=FALSE}

variablesReporte <- list(
  min = min,
  max = max,
  mean = mean
)
#skim_with(numeric = variablesReporte, append = FALSE) 
#skim(train)  %>% pander()


```

----------------------------------------------------------------

## Detección, tratamiento e imputación de datos faltantes 

A la hora de tratar con cualquier dataset hay que tener en cuenta que hay datos que pueden faltar. Es importante encontrarlos y tratarlos de manera correcta, pues podrían llevarnos a predecir de manera errónea y el modelo habría que tirarlo a la basura.

Tenemos que tener en cuenta si nuestros datos son de naturaleza 
    
- MCAR (Missing completely at Random): la probabilidad de que un dato falte es idéntica para todos los casos.
- MAR (Missing at Random): la probabilidad de que falte un valor depende de algún mecanimos conocido (pej, grupos en encuentas que son menos proclives a dar datos).
- MNAR (Missing not at Random): la probabilidad de que falte un valor depende de alguna variable no observada (pej, gente que miente).
    
Analizando nuestros datos vemos que nuestros datos faltantes pertenecen al grupo de MAR, ya que podemos tener capacidad o no para obtener cierta información de los domicilios de Boston, pero será totalmente aleatoria. Ésta es una buena noticia, ya que podemos utilizar técnicas de imputación para suplir los datos faltantes.
    
//*Para hacer un análisis de los datos que nos faltan vamos a utilizar la biblioteca VIM. Ésta biblioteca nos será muy útil ya que nos ayuda a analizar las posibles relaciones y estructuras de los valores faltantes e imputados.//* 
    
```{r plot_missing_all, message= FALSE, warning=FALSE, fig.width=40, fig.height=30}
    
##aggr_plot <- aggr(train, col=c('navyblue','red'), numbers=TRUE, sortVars=TRUE, cex.axis=.7, gap=3, ##ylab=c("Histogram of missing data","Pattern"))

```

El proceso de detección, tratamiento e imputación de datos faltantes se va a realizar de la siguiente manera:

Analizaremos los grupos antes creados por separado para ver mejor los resultados.

Variables continuas:

```{r missing_continuas_show, message=FALSE, warning=FALSE}

missing_data_continuas <- train %>%  dplyr::select(var_continuas)  %>% plot_missing(theme_config = list(legend.position = "bottom", axis.text.x =element_text(angle = 90),axis.text.y = element_text(size = rel(1))))

```

* Datos faltantes en las variables: **LotFrontage**, **MasVnrArea**, **BsmtFinSF1**, **BsmtFinSF2**, **BsmtUnfSF**, **TotalBsmtSF**, **GarageArea**.

Variables discretas:

```{r missing_discretas_show, message=FALSE, warning=FALSE}

missing_data_discretas <- train %>%  dplyr::select(var_discretas)  %>% plot_missing(theme_config = list(legend.position = "bottom", axis.text.x =element_text(angle = 90),axis.text.y = element_text(size = rel(1))))

```

* Datos faltantes en las variables: **GarageYrBlt**, **BsmtFullBath**, **BsmtHalfBath**, **GarageCars**.

Variables discretas ordinales:

```{r missing_ordinales_show, message=FALSE, warning=FALSE}

missing_data_ordinales <- train %>%  dplyr::select(var_ordinales)  %>% plot_missing(theme_config = list(legend.position = "bottom", axis.text.x =element_text(angle = 90),axis.text.y = element_text(size = rel(1))))

```

* Datos faltantes en las variables: **Electrical**, **KitchenQual**.

Variables nominales:

```{r missing_nominales_show, message=FALSE, warning=FALSE}

missing_data_nominales <- train %>%  dplyr::select(var_nominales)  %>% plot_missing(theme_config = list(legend.position = "bottom", axis.text.x =element_text(angle = 90),axis.text.y = element_text(size = rel(1))))

```

* Datos faltantes en las variables: **SalesType**, **Exterior2nd**, **Exterior1st**, **MsZoning**, **MasVnrType**.

Como hay muchas variables que no tienen valores faltantes, vamos a crear un dataset únicamente con las columnas que tienen missings para poder analizar mejor los datos. Para ello:
    
```{r get_df_missing, messge=FALSE, warning=FALSE}

na_counts <- sapply(train, function(x) sum(is.na(x)))

na_counts_sort <- sort(na_counts, decreasing = TRUE)

na_counts_sort <- na_counts_sort[1:20]

(na_counts_sort)

train_na <- train %>% dplyr::select(LotFrontage, MasVnrArea, BsmtFinSF1, BsmtFinSF2, BsmtUnfSF, TotalBsmtSF, GarageArea, GarageYrBlt, BsmtFullBath, BsmtHalfBath, GarageCars, KitchenQual, Electrical, MasVnrType,  MSZoning, Exterior1st, Exterior2nd, SaleType)

aggr_plot <- aggr(train_na,col=c('navyblue','red'), numbers=TRUE, sortVars=TRUE, cex.axis=.7, gap=3, ylab=c("Histogram of missing data","Pattern"))

```
    
Ahora podemos prestar verdadera atención a las columnas con datos faltantes. 
    
Si nos fijamos en la columna que más datos faltantes tiene, podemos ver en la descripción del dataset que son la cantidad de pies lineales que hay de acera hasta la puerta de la casa. Además, leyendo la documentación del dataset vemos que los NA's no significa que no tengan conexión con la acera (un edificio de varios pisos por ejemplo), sino que son datos faltantes. Hemos considerado que una columna con más de un 15% de datos faltantes nos va a desbalancear el dataset drásticamente, por lo que vamos a prescindir de este valor para nuestro estudio y para la imputación de missings, por lo que la borramos del dataset.
    
```{r message=FALSE, warning=FALSE, echo=FALSE}

var_columnas_eliminadas <- c(var_columnas_eliminadas,'LotFrontage')

train <- dplyr::select(train, -LotFrontage)
train_na<- dplyr::select(train_na, -LotFrontage)

#test_AA <- dplyr::select(test, -LotFrontage)

#train_test<- dplyr::select(train_test, -LotFrontage)
#full_dataset<- dplyr::select(full_dataset, -LotFrontage)
```

```{r warning=FALSE}

aggr_plot <- aggr(train_na,col=c('navyblue','red'), numbers=TRUE, sortVars=TRUE, cex.axis=.7, gap=3, ylab=c("Histogram of missing data","Pattern"))
    ```
    
Vemos en el último gráfico que, omitiendo la columna con datos faltantes mayor que el 5%, la cantidad de datos faltantes es menor que el 3%. Además vemos en la gráfica de la derecha que lo más habitual es que no falten todos los datos a la vez y a continuación que falten datos de la primera columna "GarageYtBtt". 
    
    
    d. Proporción datos faltantes. 
    
El siguiente paso es calcular la proporción de datos faltantes por columna. Para el caso en el que la proporción de datos faltantes sea menor que el 3% (0.03) imputaremos a los valores faltantes de variables cuantitativas su mediana o media, mientras que a las variables categóricas les imputaremos la categoría más frecuente. Para las columnas en que la proporcion de datos faltantes sea superior al 3% (0.03) tendremos que utilizar técnicas de imputación más avanzadas. Si en nuestro dataset se diera el caso en el que existen varias columnas de este útlimo tipo habría que realizar un análisis de sensibilidad para comprobar que no hemos alterado la naturaleza del dataset imputando los datos faltantes.


```{r}

colMeans(is.na(train_na))

```

Para el caso de las variables cuya proporción de missings es menor que el 3% (<=16 datos por columna) vamos a utilizar el método de imputar un valor de centralidad, en este caso la media. Antes de proceder a imputar, vemos que 

* Categóricas: MasVnrType, MSZoning, Functional, Electrical, KitchenQual, SaleType, Exterior1st, Exterior2nd, BsmtFullBath, BsmtHalfBath, Utilities.

* Cuantitativas: GarageYrBlt, MasVnrArea, GarageCars, GarageArea, BsmtFinSF1, BsmtFinSF2, BsmtUnfSF, TotalBsmtSF.

Para imputar de manera eficaz y sin tener que analizar por separado las variables categóricas de las cuantitativas vamos a utilizar la biblioteca HMISC. Esta biblioteca tiene dos funciones altamente potentes: impute() y aregImpute(). Se diferencian entre sí en que en la segunda puedes utilizar regresiones, bootstrapping y otros métodos para imputar valores.

```{r}

summary_antes_imputar <- summary(train)
#para las variables cuantitativas con una proporción del faltantes menor que el 3%,
#imputaremos el valor de la media

cuantitativas <- c('MasVnrArea','GarageCars','GarageArea', 'BsmtFinSF1', 'BsmtFinSF2', 'BsmtUnfSF', 'TotalBsmtSF','BsmtFullBath', 'BsmtHalfBath')

for (i in cuantitativas){
  list_values <- ifelse(is.na(train[[i]]), 
                       round(mean(train[[i]], na.rm=TRUE), 0), train[[i]])
  train[[i]] <- list_values
  }

train
#para variables categoricas con una proporción de datos faltantes menor que el 3%
#vamos a imputar el valor más frecuente.  


categoricas <- c('MasVnrType', 'MSZoning', 'Functional', 'Electrical',
'KitchenQual', 'SaleType', 'Exterior1st', 'Exterior2nd',  'Utilities')
for (i in categoricas){
  
  y = as.data.frame(table(unlist(train[[i]])))
  sorted_list <-y[with(y, order(-Freq)),]
  frecuent_value <- sorted_list$Var1[1]
  list_values <- c()
  for(j in 1:length(train[[i]])) {
    if(is.na(train[[i]][j])) {
      train[[i]][j] = frecuent_value
      na.rm=TRUE
      list_values = c(list_values, train[[i]][j])
    }
    else {
      list_values = c(list_values, train[[i]][j])
    }
  }
  train[[i]] <- list_values
}

summary_despues_imputar <- summary(train)
```

Solo nos faltaría una variable por imputar sus valores: GarageYrBlt. Esta columna indica el año en el que se construyó el garaje de la propiedad. No lo vamos a imputar con el valor medio ya que la proporción de datos faltantes es mayor al 3%, así que lo que proponemos para su imputación es lo siguiente: ya que conocemos el vecindario al que pertenecen los pisos, es lógico que el año de construcción del garaje sea similar para todo el vecindario. Vamos a proceder a agrupar los garages por vecindario e imputaremos el año medio correspondiente.

```{r}
vecindario_precioGaraje<- train %>% dplyr::select(Neighborhood, GarageYrBlt)


vecindario_agrupado <- vecindario_precioGaraje %>% 
    group_by(Neighborhood) %>% 
    summarise(mean_data = round(mean(GarageYrBlt,na.rm=TRUE),0))
summary(vecindario_agrupado)

#En la variable grouped_list tenemos los vecindarios de Boston y la media del año
#en el que fueron construidos sus garajes. Esos son los valores que usaremos para imputar.

year_corregido<- c()
for(j in 1:length(vecindario_precioGaraje$GarageYrBlt)) {
  if(is.na(vecindario_precioGaraje$GarageYrBlt[j])) {
    #obtenemos el vecindario correspondiente al NA
    vecindario = vecindario_precioGaraje$Neighborhood[j]
    #ahora que conocemos el vecindario, tenemos que saber cual es el año que le corresponde
        #Dentro de la lista de vecindarios, sacamos su numero de fila
    index_vecindario = which(grepl(vecindario, vecindario_agrupado$Neighborhood))
    
    #Entramos en este if porque hay dos vecindarios: Sawyer y SawyerW. Cuando buscamos el 
    #de Sawyer nos da el indice de los dos vecindarios, asi que nos quedamos con el primero.
    if (length(index_vecindario)>1){
      index_vecindario = index_vecindario[1]
    }
    year_a_imputar = vecindario_agrupado[index_vecindario,2]
    
    na.rm=TRUE
    year_corregido<-c(year_corregido,year_a_imputar)
  }
  else {
    year_corregido<-c(year_corregido,vecindario_precioGaraje$GarageYrBlt[j])
    next 
  }
}

year_corregido<- unlist(year_corregido)
length(year_corregido)

#actualizamos la columna en el dataset
train["GarageYrBlt"]<-year_corregido
train$GarageYrBlt


vecindario_agrupado2 <- vecindario_precioGaraje %>% 
    group_by(Neighborhood) %>% 
    summarise(mean_data = round(mean(GarageYrBlt,na.rm=TRUE),0))
summary(vecindario_agrupado2)

```

Y ya tendríamos todas las columnas con missing imputadas.

## Analisis y procesado de variables

Ahora comenzaremos con el análisis univariante de los datos del dataset. Empezaremos dicho análisis mostrando un conjunto de histogramas para las variables nominales:


```{r}
train %>%  dplyr::select(var_nominales)  %>% plot_bar()
```

A la vista de estos diagramas, observamos lo siguiente:
      * Existe una gran cantidad de variables que tienen una varianza muy reducida, tales como Street, Alley, LandContour, Condition1, Condition2, RoofStyle, RoofMtl, Heating, GarageType, SaleCondition. Estas variables pueden ser problemáticas al realizar el proceso de regresión lineal para el que este tipo de varialbes puede ser problemático, por no contar que para estos modelos este tipo de variables tienen muy poco poder predictivo.
    
    El siguiente código detectara las variables que tienen baja varianza e intentara eliminar todas aquellas que no sean significativas en una regresión de ella con la variable salePrice :

```{r}

elementosBajaVarianza <- nearZeroVar(train,freqCut = 95/5,uniqueCut = 10)

# funcion para eliminar elementos con baja correlacion
lmp <- function (modelobject) {
    if (class(modelobject) != "lm") stop("No es un objeto de tipo regresion lineal 'lm' ")
    f <- summary(modelobject)$fstatistic
    p <- pf(f[1],f[2],f[3],lower.tail=F)
    attributes(p) <- NULL
    return(p)
}

# estas columna dan problemas, la varible 3SnnPorch empieza por un número y a la hora de ejecutar el modelo para ver si son significativas en la regresión  
var_columnas_eliminadas = c(var_columnas_eliminadas,'3SsnPorch')

for(i in colnames(train)[elementosBajaVarianza]) {
  if(i != '3SsnPorch') {
    modelRegression <- lm(reformulate(termlabels = i, response = 'SalePrice') ,data=train)
    if(lmp(modelRegression) >.05) {
      var_eliminar_correlacion = c(var_eliminar_correlacion,i)
    }
  }
}

(var_eliminar_correlacion)

```

Otra cosa que se observa en los anteriores diagramas es que todas las distribuciones continen un alto grado de asimetría (Skewness), cosa que habrá que tener en cuenta por si hay que realizar algún tipo de transformación sobre ellas en futuros apartados de la práctica:
    
Ahora realizaremos el mismo análisis con las variables ordinales, que no son otra cosa que variables categóricas pero que encierran una relación de orden interna. El tratamiento de estas variables para transformarlas en categóricas y cambiar el ordenamiento alfabético que R les da por defecto:

```{r}

train %>%  dplyr::select(var_ordinales)  %>% plot_bar()

```

Se observan práctimante las mismas anomalías en en el caso anterior, variables con distribuciones muy alejadas de la normalidad y en muchos casos dichas variables apenas aportan información debido a que la mayoría de los valores están concentrados en una única categoría.

Proseguiremos con las variables contínuas:
  
```{r}
var_continuas <- c('LotArea','MasVnrArea','BsmtFinSF1','BsmtFinSF2','BsmtUnfSF','TotalBsmtSF','1stFlrSF','2ndFlrSF','LowQualFinSF','GrLivArea','GarageArea','WoodDeckSF','OpenPorchSF','EnclosedPorch', '3SsnPorch','ScreenPorch','PoolArea','MiscVal','SalePrice')

train %>%  dplyr::select(var_continuas) %>% plot_histogram()

```

Los comentarios que se pueden hacer en este caso son los siguientes:

* Muy pocas variables parecen seguir una distribución normal y casi todas tienen un fuerte sesgo hacia la izquierda (y unas pocas a la derecha), sugiriendo para muchas de ellas una transformación de tipo logarítmico. Además, algunas de ellas parecen presentar numerosos "outliers" debido a que el rango de variación de las mismas es muy elevado en una gran parte de los valores finales sin que aparezcan casi valores en los mismos. 

* La variable "Id" es una especie de clave primária organizadora de las filas y hay que eliminarla en los procesos de regresión.

  Nos centraremos ahora en mostrar con mas detalle los histograma y diagramas de densidad de las variables que describen el tamaño en superficie de cada parte en la que se compone una casa: 

```{r} 
library(gridExtra)
s1 <- ggplot(data= train, aes(x=GrLivArea)) +
        geom_density() + labs(x='Pies cuadrados habitables')
s2 <- ggplot(data=train, aes(x=as.factor(TotRmsAbvGrd))) +
        geom_histogram(stat='count') + labs(x='Numero de habitaciones por encima del sótano')
s3 <- ggplot(data= train, aes(x=`1stFlrSF`)) +
        geom_density() + labs(x='Tamaño en Pies cuadrados de la primera planta')
s4 <- ggplot(data= train, aes(x=`2ndFlrSF`)) +
        geom_density() + labs(x='Tamaño en Pies cuadrado de la segunda planta')
s5 <- ggplot(data= train, aes(x=TotalBsmtSF)) +
        geom_density() + labs(x='Tamaño en metros cuadrados del sótano')
s6 <- ggplot(data= train[train$LotArea<100000,], aes(x=LotArea)) +
        geom_density() + labs(x='Tamaño en metros cuadrados del jardin')
#s7 <- ggplot(data= train, aes(x=LotFrontage)) +
#        geom_density() + labs(x='Tamaño en metros cuadrados del jardin frontal')
s8 <- ggplot(data= train, aes(x=LowQualFinSF)) +
        geom_histogram() + labs(x='Tamaño de espacio no habitale 1ª y 2ª planta')

#layout <- matrix(c(1,2,5,3,4,8,6,7),4,2,byrow=TRUE)
grid.arrange(s1, s2, s3, s4, s5, s6, s8)
```

 Observamos que la distribución que siguen se aparta en general de la normalidad y tienen una forma similar al propio histograma del precio de la vivienda. La gráfica que muestra el tamaño en pies cuadrados de la segunda es bimodal, lo que indica que existen 2 tipos de casas diferenciadas (poblaciones distintas).


Ahora realizaremos los mismos gráficos para las variables discretas:

```{r}

train %>%  dplyr::select(var_discretas) %>% plot_histogram()

```
 
 Comentarios parecidos a el análisis de distribución de las variables contínuas se pueden hacer para estas variables. No obstante merece la pena recalcar que algunas de estas variables (YearBuilt,YearRemodAdd y YrSold) codifican años. En estos casos, para simplificar el modelo y debido a la irregular distribución de las mismas, se dividirán estas variables en rangos (de, por ejemplo, 20 años) y se creará una faceta representando esta división en el apartado de tratamiento de variables cuantitativas. 
 
 Por último representaremos en sendos diagramas de barras las variables cualitativas nominales.  Estas variables deberán convertirse en columnas de tipo "factor" en el dataset sin que el orden que tengan sea realmente importante.
 
```{r}
train %>%  dplyr::select(var_nominales) %>% plot_bar(nrow =2,ncol=2)
``` 
 
 Observamos que hay una variable nominal que tiene una gran cantidad de valores. Esa variable (denominada "Neighbourhoud") parece especialmente importante debido a que codifica el barrio al que pertenece la casa puesta a la venta, y parece que será importante en el modelo final, por la evidente correlación que habrá entre los precios de la vivienda y la zona en la que se encuentran. No obstante, es una variable con una gran cantidad de valores distintos, lo cuál podría ser un problema para el modelo de regresión lineal. A continuación realizarmos un par de diagrama de barras mostrando la distribución frente al precio de venta y el número de cassas por vecindario:
 
```{r} 
library(scales)
 gr1 <- ggplot(train[!is.na(train$SalePrice),], aes(x=Neighborhood, y=SalePrice)) +
        geom_bar(stat='summary', fun.y = "median", fill='blue') +
        theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
        scale_y_continuous(breaks= seq(0, 1800000, by=20000), labels = comma) +
        geom_label(stat = "count", aes(label = ..count.., y = ..count..), size=3) +
        geom_hline(yintercept=150000, linetype="dashed", color = "red") 

gr2 <- ggplot(data=train, aes(x=Neighborhood)) +
        geom_histogram(stat='count')+
        geom_label(stat = "count", aes(label = ..count.., y = ..count..), size=3)+
        theme(axis.text.x = element_text(angle = 45, hjust = 1))
grid.arrange(gr1, gr2)
``` 
 
  Una posible manera de quitarnos esta molesta variable es discretizándola por un umbral de precio de venta medio en la zona. Podríamos llamar a las dos colecciones "zona cara" y "zona normal". 

 La otra variable categórica que se podría tratar de la misma forma que la anterior es una varible que clasifica a la casa según un cojunto cerrado de valores que a priori no tiene un significado claro para nosotros. Mostramos las mismas gráficas para esta variable para ver si se puede seguir una estrategia similar a la de la anterior variable:
 
```{r} 

 gr1 <- ggplot(train[!is.na(train$SalePrice),], aes(x=MSSubClass, y=SalePrice)) +
        geom_bar(stat='summary', fun.y = "median", fill='blue') +
        theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
        scale_y_continuous(breaks= seq(0, 800000, by=50000), labels = comma) +
        geom_label(stat = "count", aes(label = ..count.., y = ..count..), size=3) +
        geom_hline(yintercept=150000, linetype="dashed", color = "red") 
gr2 <- ggplot(data=train, aes(x=MSSubClass)) +
        geom_histogram(stat='count')+
        geom_label(stat = "count", aes(label = ..count.., y = ..count..), size=3) +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))
grid.arrange(gr1, gr2)
```  
 
 
Ahora nos ocuparemos del análisis de la variable dependiente de nuestro modelo, el precio de las casas. En primer lugar dibujaremos su histograma:

```{r}

ggplot(train, aes(x=SalePrice)) + 
    geom_histogram(aes(y=..density..),      
                   binwidth=7000,
                   colour="black", fill="white") +
    geom_density(alpha=.2, fill="#FF6666")  

```

Vemos que esta variable tiene un importe sesgo a la izquierda y parece que un cambio de variable de tipo logarítmico podría convertirla en una variable con distribución normal, cosa importante para el modelo lineal de regresión múltiple. El sesgo es muy fácilmente explicable por la naturaleza de la propia variable: la mayoría de las casas deberán tener un precio ajustado a la distribución de la riqueza entre los habitantes de la ciudad, y muy pocas tendrán un gran valor (casas lujosas) o serán infraviviendas. Confirmemos esta hipótesis realizando el cambio de variable en la misma y dibujando su función de distribución normal aproximada:

```{r}

fitDistribution <- fitdistr(log10(train$SalePrice), densfun = "normal")
  ggplot(data = train) +
  geom_histogram(mapping = aes(x = log10(SalePrice), y = ..density..), col="white") +
  stat_function(fun = dnorm, args = list(mean = fitDistribution$estimate[1], sd = fitDistribution$estimate[2], log = F), 
  color="red", lwd=1)

```

Vemos que, efectivamente, lo que hemos comentado en el anterior apartado se cumple. 
Detectamos también que el rango dinámico de la variable es muy grande en su parte    derecha sin que apenas haya valores en dicho intervalo, lo que invita a pensar en la presencia de "outliers" (casas de un gran valor económico reservadas a la gente más rica de la ciudad). Dibujaremos sendos diagramas de cajas con la variable original y la variable transformada:

```{r}

graf3 <- train %>% dplyr::select(SalePrice) %>%
  na.omit() %>%
  ggplot(aes(x=0,y=SalePrice)) +
    geom_boxplot(outlier.colour="black", outlier.shape=16,
             outlier.size=2, notch=FALSE)

graf4 <- train %>% dplyr::mutate(log10_saleprice = log10(SalePrice)) %>%
  dplyr::select(log10_saleprice) %>%
  na.omit() %>%
  ggplot(aes(x=0,y=log10_saleprice)) +
    geom_boxplot(outlier.colour="black", outlier.shape=16,
             outlier.size=2, notch=FALSE)

ggarrange(graf3,graf4)

```

Vemos claramente la existencia de Outliers en esta variable que la transformación logarítmica no es capaz de resolver, tanto en los valores superiores como en los inferiores. En una parte futura de este apartado, detectaremos y almacenaremos en sendas variables estos Outliers para todas las variables independientes y tomar una decisión de cómo transformales en los apartados de tratamiento de variables cualitativas y cuantitativas.
   
Ahora realizaremos un conjunto de gráficos cuantil/cuantil sobre las variables continuas y discretas para corroborar que hay pocas variables con una distribución normal:

```{r}

train %>% plot_qq(sampled_rows = 1000L)

```

Las que más se aproximan a esta distribución son: LotArea, LotFrontage, GrLivArea, TotalBsmtSF y X1stFlrSF. Este diagrama pone en evidencia también la gran cantidad de Outliers que tienen algunas variables.
  
Almacenaremos el grado de asimetría de dichas variables para en un futuro poder tener un criterio más claro de qué variables son candidatas a un tipo de transformación logarítmica:

```{r}
var_continuas_discretas = c(var_continuas,var_discretas)
library(moments)
listasVariablesSkewness <-  na.omit(train %>% dplyr::select(var_continuas_discretas)) %>% skewness()
variablesSkewnessAlto <- listasVariablesSkewness[abs(listasVariablesSkewness) > 0.8]  

```

Ahora procedermos a realizar el análisis vivariante de nuestros datos. Empezaremos con analizar los coeficientes de correlación entre las distintas variables. El siguiente diagrama intenta dibujar un mapa de calor de dichas correlaciones para las variables contínuas, pero debido a la gran cantidad de varibles en dicho diagrama no se puede visualizar nada con claridad:


```{r}

splitDataset <- split_columns(train, binary_as_factor = FALSE)
plot_correlation(na.omit(splitDataset$continuous), type = "c" ,maxcat = 5L,theme_config = list(legend.position = "bottom", axis.text.x =element_text(angle = 90),axis.text.y = element_text(size = rel(0.4))  ))

```

Crearemos una matriz de correlaciones con las variables continuas para intentar evidencia de mejor forma estos posibles casos de variables fuertemente correlacionadas que podrían desestabilizar el resultado del proceso de regresión lineal:

```{r}
library(corrr)
corrmatrix <-corrr::correlate(na.omit(train %>% dplyr::select(var_continuas)))
rplot(corrmatrix, legend = TRUE, shape = 16,print_cor = TRUE) +theme(axis.text.x = element_text(angle = 90))

```

Con esta matriz se observan lo siguiente:
      * La mayor parte de las variables representan una correlación positiva con el precio de la vivienda y entre ellas. Eso es normal debido a que muchas representan cantidades (pies cuadrados en las distintas zonas en las que se descompone las estancias de la vivienda, número y tamaño de cada planta, tamaño de garage y sótanos, etc. ). Evidentemente, cuandos mayores son estos números, normalmente mayor será el valor de la vivienda.
      * Las variables 1stFlrSF y TotalBsmtSF estan fuertemente correladas, habría que quitar una de ellas en el modelo (es normal que haya una correlacion entre la superficie total del sótano y la de la primera planta)
      * Existen correlaciones moderadas entre las variables GrLivArea y 1stFlrSF y 2ndFlrSF, no obstante un análisis más detentenido nos muestra que la suma de las siguientes variables tienen correlacion unidad, lo cuál es un punto a favor en la consistencia de los datos de estas variables en el dataset:

```{r}
cor(train$GrLivArea, (train$`1stFlrSF` + train$`2ndFlrSF` + train$LowQualFinSF))
```

 Esto es lógico debido a que la suma de las superficies habitables de la primera y segunda planta mas la superficie de "baja calidad" tienen que coicidir con la superficie total habitable sin contar los sótanos. Es por ello que estas variables o hay que transformarlas para evitar este caso de correlación perfecta o bien eliminar del modelo alguna de ellas. La decisión se tomará mas adelante.
      
  A continuación mostraremos un tipo de gráfica que muestra de forma más visual la anterior matriz de correlación. En ella cuando más cerca están unos puntos de otros existe una mayor similitud entre las distintas variables. Cada una de ellas está a su vez enlazada con una "banda" de color azul o rojo que cuantifica el grado de correlación entre las variables. En ella ya vemos que la variable objetivo de estudio, el precio de venta de la casa, está muy influenciada por todas aquellas variables continuas que cuantifican la superficie en la que se dividen las distintas parcelas de la propiedad (habitaciones, garage, porche, sótano, etc.). 


```{r}
network_plot(corrmatrix)
``` 

  Ahora proseguiremos el análisis con las variables discretas. Como antes, generaremos una matriz de correlación y estudiaremos los resultados:

```{r}
corrmatrix2 <-corrr::correlate(na.omit(train %>% dplyr::select(var_discretas)))
rplot(corrmatrix2, legend = TRUE, shape = 16,print_cor = TRUE)+theme(axis.text.x = element_text(angle = 90))
```
```{r}
network_plot(corrmatrix2)
```

 * Existe una fuerte correlación entre las variables GarageYrBlt y YearBuilt y YearRemodAdd, con ello podemos quitarnos la variable GarageYrBlt.

   Ahora intentaremos hacer este mismo análisis agrupando tanto variables contínuas como discretas, El resultado es el siguiente:

```{r}
corrmatrix3 <-corrr::correlate(na.omit(train %>% dplyr::select(var_continuas_discretas)))
rplot(corrmatrix3, legend = TRUE, shape = 16,print_cor = TRUE)+theme(axis.text.x = element_text(angle = 90))
network_plot(corrmatrix3)
```

  Aqui Observamos una correlación muy fuerte entre las variables GarageCars y GarageArea, con lo que nos podemos quitar la variable GarageCars.Es lógico pensar que el número de coches que caben en una plaza de garage dependa de la superficie de ésta.
   *  Existe una correlacion muy fuerte también entre las variables GrLiveArea y TotRmsAbvGrd (total de habitaciones), con lo que podemos quitar esta última del análisis al parecer más sencilla de entender la primera de las variables.
   *  Hay una fuerte correlación entre las variables YearRemodAdd y las variables YearBuild y GarageYrBuild. Esto indica que en muchas de ellas el año en que se construyó el garage coincide con el año en que se contruyó la casa. En el caso de la variable YearRemodAdd parece que se ha hecho coincidir con el año de construcción si la casa no ha sufrido reformas.
   
   La siguiente función confirmará nuestras sospechas, buscando variables con fuertes correlaciones entre ellas:


```{r}

correlacionesProblematicas <- findCorrelation(cor(na.omit(train %>% dplyr::select(var_continuas_discretas))),cutoff = 0.8, verbose = FALSE, names = TRUE)
correlacionesProblematicas

```

    Comprobamos que, efectivamente, las variables antes comentadas están entre las que aparecen en el listado.

    Ahora intentaremos mostrar en un gráfico de barras el grado de correlación entre las variables anteriormente analizadas y la variable objeto de nuestro análisis:
    
```{r}



rplot(corrmatrix3, legend = TRUE, shape = 16,print_cor = TRUE)+theme(axis.text.x = element_text(angle = 90))

correlacionesSalesPrice <-focus(corrmatrix3,SalePrice)

correlacionesSalesPrice%>%  arrange(SalePrice) %>%  ggplot(aes(x=rowname ,y=SalePrice,fill=factor(rowname))) +
  geom_bar(position="dodge",stat="identity") + 
  coord_flip() +
  ggtitle("Correlacion entre las variables numéricas y el precio de las casas")


```

    En este diagrama se muestra más claramente lo que ya se ha comentado con anterioridad: casi todas las variables tienen correlaciones positivas con el precio excepto unas pocas (sería interesante el averiguar por qué, ya que serían factores que influyen negativamente en el precio de una vivienda). Además las variables con mayores correlaciones tiene que ver con la superficie habitable de la casa y la superficie de la primera planta (lo que muestra que la mayoría de las casas tienen una única planta. El tener una segunda planta influye moderadamente en el precio de la vivienda). También hay correlaciones moderadas entre las características del garage, el año de construcción, la superficie del sótano, etc. Por lo tanto, estas variables deberían entrar significativamente en el modelo de regresión que generemos en esta práctica.
    
    Ahora realizaremos unos cuantos diagramas de dispersión entre las variables contínuas y el precio de la vivienda para ver si existen relaciones lineales entre dichas variables (importante para saber si el modelo de regresión lineal es el más adecuado para el problema que tenemos en esta práctica):

```{r}

na.omit(train %>% dplyr::select(var_continuas)) %>% plot_scatterplot( by = "SalePrice", sampled_rows = 1000L) 

#geom_smooth(method=lm, se=FALSE, fullrange=TRUE)

```

   Observamos que sí que existen ciertas relaciones apróximadas pero con algunas anomalías que comentamos a continuación:
  
  * Existen muchos valores concentrados en el valor cero para muchas de las variables (es normal, por ejemplo, que haya muchas casas que no tengan segundo piso, por lo que para ellas la variable que contabiliza su superficie sea cero).
  * Se ven numerosos "outliers" en muchas variables, lo que es indicativo de casas con características especiales, tanto a la baja como al alza. En particular, la variable "LotArea" es un indicativo de casas de lujo para valores extremadamente altos de la misma (en su gráfica se muestran claramente estos "outliers"). Otra de las variables que muestran casas fuera de lo común es "3SsnPorch", en donde vemos que muy pocas casas la tienen informada con un valor mayor que cero.


 En cuanto a la detección de Outliers, como se ha indicado con anterioridad, existen indicios más que suficientes para inferir que, efectivamente, en este dataset existe más de una casa que podría crear problemas en el modelo de regresión lineal. Para detectarlos y almacenarlos en una lista para su posterior tratamiento, ejecutaremos el siguiente código, que además mostrará un conjunto de diagramas de caja con las variables continuas del dataset:

```{r}
library(EnvStats)
listaOutliers <- list()
#listaBoxPlots <- c()
dataset_var_continuas <- train %>% dplyr::select(var_continuas)
iterator = 1 
for(i in colnames(dataset_var_continuas)) {
  outlier_values <- boxplot.stats(dataset_var_continuas[[i]])$out
  boxPlotDibujar <- boxplot(dataset_var_continuas[[i]], main=i, boxwex=0.1)
  if(i %in% c('LotArea','1stFlrSF','GrLivArea','PoolArea','TotalBsmtSF')) {
    boxPlotDibujar
  }
  #listaBoxPlots <- c(listaBoxPlots,boxPlotDibujar)
  outliersRosen <- rosnerTest(dataset_var_continuas[[i]], k = 4, warn = F)
  listaOutliers[[iterator]] <- outliersRosen
   iterator<- iterator +1
}


#library(gridExtra)
#n <- length(listaBoxPlots)
#nCol <- floor(sqrt(n))
#do.call("grid.arrange", c(listaBoxPlots, ncol=nCol))


#for(i in listaOutliers) {
#  print(c(i$data.name,i$n.outliers))
#}

```

  A continuación, almaceneramos en un conjunto de variables todas las recomendaciones que se han hecho en este punto para proceder en partes posteriores de la práctica a llevar a cabo dichas recomendaciones (eliminar columnas del modelo por posibilidad de autocorrelacines, eliminacion de columnas varias por baja varianza de las mismas, etc).


```{r}
var_modelo_with_SalePrice = c(var_modelo,'SalePrice')
var_columnas_eliminadas = c('TotRmsAbvGrd','GarageYrBlt','GarageCars','TotalBsmtSF','1stFlrSF','2ndFlrSF','BsmtFinSF2','1stFlrSF','2ndFlrSF','FullBath','HalfBath','BsmtFullBath','BsmtHalfBath','OpenPorchSF','3SsnPorch','EnclosedPorch','ScreenPorch','WoodDeckSF','GarageFinish','hasBasement','hasFirePlaces','LotFrontage')
var_columnas_eliminadas_bajo_p_valor = c('LandSlope')
var_transformacion_log = c('TotalSF')
var_eliminar_correlacion = c('TotRmsAbvGrd','GarageYrBlt','GarageCars')

```


5. Transformaciones de variables cuantitativas (1 punto)

  Ahora procederemos a realizar el procesado de las variables cuantitativas, tanto contínuas como discretas. Lo primero que haremos será contruir 3 nuevas variables como sigue:
  * TotalSF : será la suma de pies cuadrados entre sótano, primera planta y segunda planta.
  * Total_Bathrooms: llevará cuenta del número total de cuartos de baño existentes en la casa, contabilizando los baños pequeños con un peso inferior.
  * Total_porch_SF: llevará cuente del número todal de pies cuadrados existentes en los diferentes porches.
  
  Evidentemente, estas variables sustituyen en el modemo final a las variables de las que se componen. Para no destruir información, además, en el apartado de procesado de variables cualitativas crearemos nuevas variables facetadas que indiquen si una casa tiene segundo piso y porche, porque no todas las casas tienen estas dos características. Así nos quitamos el problema que vimos en el apartado de análisis exploratorio con numerosos ceros en algunas de estas variables.

```{r}

train <- train %>% dplyr::mutate( TotalSF = TotalBsmtSF + `1stFlrSF` + `2ndFlrSF`  )
 train <- train %>% dplyr::mutate( Total_Bathrooms = FullBath + 0.5*HalfBath +  BsmtFullBath + 0.5*BsmtHalfBath )
 train <- train %>% dplyr::mutate( Total_porch_SF = OpenPorchSF +`3SsnPorch` +  EnclosedPorch + ScreenPorch + WoodDeckSF )
 #train <- train %>% dplyr::mutate( TotalSqrFootage = BsmtFinSF1 + BsmtFinSF2 + !!as.symbol(firsrtFlrSF) + #!!as.symbol(secondFlrSF)  )
 
test <- test %>% dplyr::mutate( TotalSF = TotalBsmtSF + `1stFlrSF` + `2ndFlrSF`  )
 test <- test %>% dplyr::mutate( Total_Bathrooms = FullBath + 0.5*HalfBath +  BsmtFullBath + 0.5*BsmtHalfBath )
 test <- test %>% dplyr::mutate( Total_porch_SF = OpenPorchSF +`3SsnPorch` +  EnclosedPorch + ScreenPorch + WoodDeckSF ) 
#test <- test %>% dplyr::mutate( TotalSqrFootage = BsmtFinSF1 + BsmtFinSF2 + !!as.symbol(firsrtFlrSF) + #!!as.symbol(secondFlrSF)  )
 
# esta variable tiene los pies cuadrados "oficiales" del interior de la casa
validation <- validation %>% dplyr::mutate( TotalSF = TotalBsmtSF + `1stFlrSF` + `2ndFlrSF`  )
# esta variable tiene los pies cuadrados de los cuartos de baño de la casa
validation<- validation %>% dplyr::mutate( Total_Bathrooms = FullBath + 0.5*HalfBath +  BsmtFullBath + 0.5*BsmtHalfBath )
 # esta variable tiene los pies cuadrados del porche
validation <- validation %>% dplyr::mutate( Total_porch_SF = OpenPorchSF +`3SsnPorch` +  EnclosedPorch + ScreenPorch + WoodDeckSF ) 
 # esta variable tiene los pies cuadrados finalizados de la casa (tiene en cuenta las variables de sotano acabado y no tiene en cuenta la variable TotalBsmtSF)
 #train_test <- train_test %>% dplyr::mutate( TotalSqrFootage = BsmtFinSF1 + BsmtFinSF2 + TotalBsmtSF+ #!!as.symbol(firsrtFlrSF) + !!as.symbol(secondFlrSF)  ) 
 
var_creadas_transformacion = c( 'TotalSF','Total_Bathrooms','Total_porch_SF','hasPool','hasGarage','hasBasement','hasFirePlaces','has2ndFloor')
 
train %>%  dplyr::select('TotalSF','Total_Bathrooms','Total_porch_SF') %>% plot_histogram()

```

  Otro procesamiento que realizaremos sobre estas variables es cuantificar las variables que portan los años de reforma y construcción de la casa en rangos de 30 años, para simplificar el modelo final generado. Esta cuantificación transformará estas variables en variables categóricas. El código que realiza la transformación es el siguiente:

```{r}
# YearBuilt: discretizamos la variable en tramos
# YearRemodAdd: discretizamos la variable en tramos
train$YearBuilt <- cut(train$YearBuilt, 
                   breaks=c(-Inf, 1930, 1960, 1990,Inf), 
                   labels=c("1900_1930","1930_1960","1960_1990","1990_"))   
test$YearBuilt <- cut(test$YearBuilt, 
                   breaks=c(-Inf, 1930, 1960, 1990,Inf), 
                   labels=c("1900_1930","1930_1960","1960_1990","1990_"))   
validation$YearBuilt <- cut(validation$YearBuilt, 
                   breaks=c(-Inf, 1930, 1960, 1990,Inf), 
                   labels=c("1900_1930","1930_1960","1960_1990","1990_"))   

      
train$YearRemodAdd <- cut(train$YearRemodAdd, 
                   breaks=c(-Inf, 1930, 1960, 1990,Inf), 
                   labels=c("1900_1930","1930_1960","1960_1990","1990_"))   
test$YearRemodAdd <- cut(test$YearRemodAdd, 
                   breaks=c(-Inf, 1930, 1960, 1990,Inf), 
                   labels=c("1900_1930","1930_1960","1960_1990","1990_"))   
validation$YearRemodAdd <- cut(validation$YearRemodAdd, 
                   breaks=c(-Inf, 1930, 1960, 1990,Inf), 
                   labels=c("1900_1930","1930_1960","1960_1990","1990_"))   

```

  Continuaremos este apartado realizando la transformación logarítmica tanto de la variable SalePrice como de las variables con alto grado de asimetría. Debido a que algunas de estas variables tienen valores nulos, sumaremos uno a la funció logarítmica para evitar errores en el cálculo del logaritmo.  El siguiente código realiza estas transformaciones:

```{r}

log_transform<- function(x, na.rm=FALSE) (log(x +1))
variablesTransformar = names(variablesSkewnessAlto)[!names(variablesSkewnessAlto) %in% var_columnas_eliminadas  & !names(variablesSkewnessAlto) %in% var_eliminar_correlacion ]

#variablesTransformar <- c(variablesTransformar,'TotalSF')

for(i in 1:ncol(train)){
 
        nombreCol = names(train)[i]
  
        if(nombreCol == 'MasVnrArea' | nombreCol == 'MiscVal' | nombreCol == 'SaleCondition' ) {
         
        } else
        if (nombreCol %in% variablesTransformar & nombreCol != 'SalePrice'){
            
            train[,i] <- log(train[,i] +1)
            #test[,i] <- log(test[,i] +1)
            #validation[,i] <- log(validation[,i] +1)
        } else if(nombreCol == 'SalePrice'){
            train[,i] <- log(train[,i])
            #test[,i] <- log(test[,i])
            #validation[,i] <- log(validation[,i])
        }else if(nombreCol == 'TotalSF'){
            train[,i] <- log(train[,i])
            #test[,i] <- log(test[,i])
            #validation[,i] <- log(validation[,i])
        } 
    
}


for(i in 1:ncol(test)){
 
        nombreCol = names(test)[i]
  
        
        if(nombreCol == 'MasVnrArea' | nombreCol == 'MiscVal' | nombreCol == 'SaleCondition' ) {
         
        } else
        if (nombreCol %in% variablesTransformar & nombreCol != 'SalePrice'){
            
            #train[,i] <- log(train[,i] +1)
            test[,i] <- log(test[,i] +1)
            #validation[,i] <- log(validation[,i] +1)
        } else if(nombreCol == 'SalePrice'){
            #train[,i] <- log(train[,i])
            test[,i] <- log(test[,i])
            #validation[,i] <- log(validation[,i])
        }else if(nombreCol == 'TotalSF'){
            #train[,i] <- log(train[,i])
            test[,i] <- log(test[,i])
            #validation[,i] <- log(validation[,i])
        } 
    
}


for(i in 1:ncol(validation)){
 
        nombreCol = names(validation)[i]
        if(nombreCol == 'MasVnrArea' | nombreCol == 'MiscVal' | nombreCol == 'SaleCondition' ) {
         
        } else
        if (nombreCol %in% variablesTransformar & nombreCol != 'SalePrice'){
            
            #train[,i] <- log(train[,i] +1)
            #test[,i] <- log(test[,i] +1)
            validation[,i] <- log(validation[,i] +1)
        } else if(nombreCol == 'SalePrice'){
            train[,i] <- log(train[,i])
            #test[,i] <- log(test[,i])
            validation[,i] <- log(validation[,i])
        }else if(nombreCol == 'TotalSF'){
            train[,i] <- log(train[,i])
            #test[,i] <- log(test[,i])
            validation[,i] <- log(validation[,i])
        } 
    
}



```


 Por último, realizaremos un normalizado de las variables para intentar que tengan media 0 y desviación típica 1, pero esa normalización se realizará en el siguiente punto una vez se hayan tratado las variables cualitativas y se hayan creado las variables de tipo factor que sean necesarias.

6. Procesado de variables cualitativas (1 punto)

  Comenzaremos este apartado creando las siguientes variables como complemento a la información en pies cuadrados de las distintas partes que componen una vivienda:
  
  * hasPool : variable categórica que indica si la vivienda tiene piscina o no.
  * hasBasement : variable categórica que indica si la vivienda tiene sótano o no.
  * has2ndFloor: variable categórica que indica si la vivienda tiene segunda planta o no.

   Habrá que tener cuidado con estas variables al añadirlas al modelo porque podrían estar altamente correladas con las variables que indican el tamaño en superficie de estos 3 elementos.

```{r}

#MSSubClass: 

test <-  test %>% dplyr::mutate( hasPool := ifelse(PoolArea > 0, "True", "False")) 
train <-  train %>% dplyr::mutate( hasPool := ifelse(PoolArea > 0, "True", "False"))  
validation <-  validation %>% dplyr::mutate( hasPool := ifelse(PoolArea > 0, "True", "False"))  
 
#test <-  test %>% dplyr::mutate( hasGarage := ifelse(GarageArea > 0, "True", "False")) 
#train <-  train %>% dplyr::mutate( hasGarage := ifelse(GarageArea > 0, "True", "False"))  
 
test <-  test %>% dplyr::mutate( hasBasement := ifelse(TotalBsmtSF > 0, "True", "False")) 
train <-  train %>% dplyr::mutate( hasBasement := ifelse(TotalBsmtSF > 0, "True", "False")) 
validation <-  validation %>% dplyr::mutate( hasBasement := ifelse(TotalBsmtSF > 0, "True", "False"))  


test <-  test %>% dplyr::mutate( hasFirePlaces := ifelse(Fireplaces > 0, "True", "False")) 
train <-  train %>% dplyr::mutate( hasFirePlaces := ifelse(Fireplaces > 0, "True", "False")) 
validation <-  validation %>% dplyr::mutate( hasFirePlaces := ifelse(Fireplaces > 0, "True", "False")) 
 
test <-  test %>% dplyr::mutate( has2ndFloor := ifelse(`2ndFlrSF`  > 0, "True", "False")) 
train <-  train %>% dplyr::mutate( has2ndFloor := ifelse(`2ndFlrSF`  > 0, "True", "False")) 
validation <-  validation %>% dplyr::mutate( has2ndFloor := ifelse( `2ndFlrSF`  > 0, "True", "False"))    

```

   A continuación transformaremos en columnas de tipo Factor aquellas que tiene valores alfanuméricos y que no parece que tengan un orden natural:

```{r}

library(plyr)

nombresVariablesFactores  <- c('MiscFeature','Alley','Fence','LotConfig','GarageType','MSZoning','Exterior1st','Exterior2nd','Electrical','SaleType','SaleCondition','Foundation','Heating','RoofStyle',
'RoofMatl','LandContour','BldgType','HouseStyle','Neighborhood','Condition1','Condition2','MoSold','YrSold','Street','LotShape','Utilities','LandSlope','MasVnrType','BsmtFinType2','CentralAir','Functional','PavedDrive','hasPool','hasBasement','hasFirePlaces')


for(i in nombresVariablesFactores){
        train[[i]] <- as.factor(train[[i]])
        test[[i]] <- as.factor(test[[i]])
        validation[[i]] <- as.factor( validation[[i]])
}


train$MSSubClass <- as.factor(train$MSSubClass)
train$MSSubClass<-revalue(train$MSSubClass, c('20'='1_story_1946_', '30'='1_story_1945_', '40'='1_story_unf_attic', '45'='1_5_story_unf', '50'='1_5 story_fin', '60'='2_story_1946_', '70'='2_story_1945_', '75'='2_5_story_all_ages', '80'='split_multi_level', '85'='split_foyer', '90'='duplex_all_style_age', '120'='1_story_PUD_1946_', '150'='1_5_story_PUD_all', '160'='2_story_PUD_1946', '180'='PUD_multilevel', '190'='2_family_conversion'))

test$MSSubClass <- as.factor(test$MSSubClass)
test$MSSubClass<-revalue(test$MSSubClass, c('20'='1_story_1946_', '30'='1_story_1945_', '40'='1_story_unf_attic', '45'='1_5_story_unf', '50'='1_5 story_fin', '60'='2_story_1946_', '70'='2_story_1945_', '75'='2_5_story_all_ages', '80'='split_multi_level', '85'='split_foyer', '90'='duplex_all_style_age', '120'='1_story_PUD_1946_', '150'='1_5_story_PUD_all', '160'='2_story_PUD_1946', '180'='PUD_multilevel', '190'='2_family_conversion'))

validation$MSSubClass <- as.factor(validation$MSSubClass)
validation$MSSubClass<-revalue(validation$MSSubClass, c('20'='1_story_1946_', '30'='1_story_1945_', '40'='1_story_unf_attic', '45'='1_5_story_unf', '50'='1_5 story_fin', '60'='2_story_1946_', '70'='2_story_1945_', '75'='2_5_story_all_ages', '80'='split_multi_level', '85'='split_foyer', '90'='duplex_all_style_age', '120'='1_story_PUD_1946_', '150'='1_5_story_PUD_all', '160'='2_story_PUD_1946', '180'='PUD_multilevel', '190'='2_family_conversion'))
```

  Y por último, todas las variables que encierran una relación de orden en ellas (por ejemplo, que sirven para cuantificar una característica de peor a mejor), se convierten en variables de tipo factor, pero estableciendo los distintos niveles de 0 a el valor máximo en función del valor que representan. El siguiente código realiza dicha transformación.


```{r}

#OverallQual, OverallCond (dejarlas como estan)
levesl1_10 <- c("Very Poor","Poor","Fair","Below Average","Average","Above Average","Good","Very Good","Excellent","Very Excellent")

#ExterQual , ExterCond , HeatingQC, KitchenQual,GarageQual,GarageCond
return_position1_5 <- function(elements) {
    levesl1_5 <- c('Po','Fa','TA','Gd','Ex')
    pos <- match(elements,levesl1_5)
    elem <- which(levesl1_5 %in% elements)
    return(levesl1_5[elem])
}


#BsmtQual,BsmtCond,FireplaceQu
return_position1_6 <- function(elements) {
    levesl1_6 <- c('NA','Po','Fa','TA','Gd','Ex')
    pos <- match(elements,levesl1_6)
    elem <- which(levesl1_6 %in% elements)
    return(levesl1_6[elem])
}


#BsmtExposure
return_position1_5_B <- function(elements) {
    levesl1_5_B <- c('NA','No','Mn','Av','Gd')
    pos <- match(elements,levesl1_5_B)
    elem <- which(levesl1_5_B %in% elements)
    return(levesl1_5_B[elem])
}


#BsmtFinType1 , BsmtFinType2
return_position1_7 <- function(elements) {
    levesl1_7 <- c('NA','Unf','LwQ','Rec','BLQ','ALQ','GLQ')
    pos <- match(elements,levesl1_7)
    elem <- which(levesl1_7 %in% elements)
    return(levesl1_7[elem])
}

#CentralAir
levesl_2 <- c('N','Y')  

#GarageFinish
return_levels_garage <- function(elements) {
    levels_garage <-c('NA','Unf','RFn','Fin')
    pos <- match(elements,levels_garage)
    elem <- which(levels_garage %in% elements)
    return(levels_garage[elem])
}


# PoolQC
return_levesl_poolQC <- function(elements) {
    levesl_poolQC <- c('NA','Fa','TA','Gd','Ex')
    pos <- match(elements,levesl_poolQC)
    elem <- which(levesl_poolQC %in% elements)
    return(levesl_poolQC[elem])
}


library(forcats)

      #OverallCond
      train <- train %>% dplyr::mutate( ExterQual:=fct_relevel(ExterQual,return_position1_5))
      test <- test %>% dplyr::mutate( ExterQual:=fct_relevel(ExterQual,return_position1_5))
     validation <- validation %>% dplyr::mutate( ExterQual:=fct_relevel(ExterQual,return_position1_5))
      #ExterCond , 
      train <- train %>% dplyr::mutate( ExterCond := fct_relevel(ExterCond,return_position1_5))
      test <- test %>% dplyr::mutate( ExterCond := fct_relevel(ExterCond,return_position1_5))
      validation <- validation %>% dplyr::mutate( ExterCond := fct_relevel(ExterCond,return_position1_5))
      #HeatingQC, 
      train <- train %>% dplyr::mutate( HeatingQC := fct_relevel(HeatingQC,return_position1_5))
      test <-  test %>% dplyr::mutate( HeatingQC := fct_relevel(HeatingQC,return_position1_5))
      validation <- validation %>% dplyr::mutate( HeatingQC := fct_relevel(HeatingQC,return_position1_5))
      #KitchenQual,
      train <- train %>% dplyr::mutate( KitchenQual := fct_relevel(KitchenQual,return_position1_5))
      test <-  test %>% dplyr::mutate( KitchenQual := fct_relevel(KitchenQual,return_position1_5))
      validation <-  validation %>% dplyr::mutate( KitchenQual := fct_relevel(KitchenQual,return_position1_5))
      #GarageQual,
      train <- train %>% dplyr::mutate( GarageQual := fct_relevel(GarageQual,return_position1_5))
      test <-  test %>% dplyr::mutate( GarageQual := fct_relevel(GarageQual,return_position1_5))
      validation <-  validation %>% dplyr::mutate( GarageQual := fct_relevel(GarageQual,return_position1_5))
      #GarageCond
      train <- train %>% dplyr::mutate( GarageCond := fct_relevel(GarageCond,return_position1_5))
      test <-  test %>% dplyr::mutate( GarageCond := fct_relevel(GarageCond,return_position1_5))
     validation <-  validation %>% dplyr::mutate( GarageCond := fct_relevel(GarageCond,return_position1_5))
      #BsmtQual
      train <- train %>% dplyr::mutate( BsmtQual := fct_relevel(BsmtQual,return_position1_6))
      test <-  test %>% dplyr::mutate( BsmtQual := fct_relevel(BsmtQual,return_position1_6))
      validation <-  validation %>% dplyr::mutate( BsmtQual := fct_relevel(BsmtQual,return_position1_6))
      #BsmtCond,
      train <- train %>% dplyr::mutate( BsmtCond := fct_relevel(BsmtCond,return_position1_6))
      test <- test %>% dplyr::mutate( BsmtCond := fct_relevel(BsmtCond,return_position1_6))
      validation <- validation %>% dplyr::mutate( BsmtCond := fct_relevel(BsmtCond,return_position1_6))
      #FireplaceQu
      train <- train %>% dplyr::mutate(FireplaceQu := fct_relevel(FireplaceQu,return_position1_6))
      test <-  test %>% dplyr::mutate(FireplaceQu := fct_relevel(FireplaceQu,return_position1_6))
     validation <-  validation %>% dplyr::mutate(FireplaceQu := fct_relevel(FireplaceQu,return_position1_6))
      #BsmtExposure
      train <- train %>% dplyr::mutate( BsmtExposure := fct_relevel(BsmtExposure,return_position1_5_B))
      test <-  test %>% dplyr::mutate( BsmtExposure := fct_relevel(BsmtExposure,return_position1_5_B))
      validation <-  validation %>% dplyr::mutate( BsmtExposure := fct_relevel(BsmtExposure,return_position1_5_B))
      #BsmtFinType1 
      train <- train %>% dplyr::mutate( BsmtFinType1 := fct_relevel(BsmtFinType1,return_position1_7))
      test <-  test %>% dplyr::mutate( BsmtFinType1 := fct_relevel(BsmtFinType1,return_position1_7))
      validation <-  validation %>% dplyr::mutate( BsmtFinType1 := fct_relevel(BsmtFinType1,return_position1_7))
      
      #BsmtFinType2
      train <- train %>% dplyr::mutate( BsmtFinType1 := fct_relevel(BsmtFinType2,return_position1_7))
      test <-  test %>% dplyr::mutate( BsmtFinType1 := fct_relevel(BsmtFinType2,return_position1_7))
      validation <-  validation %>% dplyr::mutate( BsmtFinType1 := fct_relevel(BsmtFinType2,return_position1_7))
      
     #GarageFinish
      train <- train %>% dplyr::mutate( GarageFinish := fct_relevel(GarageFinish,return_levels_garage))
      test <-  test %>% dplyr::mutate( GarageFinish := fct_relevel(GarageFinish,return_levels_garage))
      validation <-  validation %>% dplyr::mutate( GarageFinish := fct_relevel(GarageFinish,return_levels_garage))
      
      # PoolQC
      train <- train %>% dplyr::mutate( PoolQC := fct_relevel(PoolQC,return_levesl_poolQC))
      test <-  test %>% dplyr::mutate( PoolQC := fct_relevel(PoolQC,return_levesl_poolQC))
      validation <-  validation %>% dplyr::mutate( PoolQC := fct_relevel(PoolQC,return_levesl_poolQC))


# para dummify variables si es necesario tenemos esta funcion del paquete dataexplorer
#train <- dummify(train, maxcat = 50L, select = var_nominales)
   
```

 Y por último, trataremos de centrar y normalizar todas las variables numéricas una vez convertidas en factores en los anteriores pasos. Esto se realizará pensando sobre todo en el paso de aplicación del método de selección de variables "lasso", que exige que todas las variables numéricas tengan varianza 1 para evitar sesgos en el modelo resultante. El siguiente código realizará esta función:

```{r}
train_sin_na <- train %>%  na.omit() %>% dplyr::select(-Id)
preProcValuesTrain <- preProcess(train_sin_na  %>% dplyr::select(-OverallQual, -OverallCond),method = c("center", "scale"))

test_sin_na <- test %>%  na.omit() %>% dplyr::select(-Id)
preProcValuesTest <- preProcess(test_sin_na  %>% dplyr::select(-OverallQual, -OverallCond),method = c("center", "scale"))

validation_sin_na <- validation %>%  na.omit() %>% dplyr::select(-Id)
preProcValuesValidation <- preProcess(validation_sin_na  %>% dplyr::select(-OverallQual, -OverallCond),method = c("center", "scale"))

```

7. Selección de variables (1 punto)

  Teniendo en cuanto todo lo dicho en los anteriores apartados, las variables con las que al final nos quedaremos para el cálculo del modelo final serán las siguientes:

```{r}

var_modelo = c( 'TotalSF','GrLivArea','LotArea','Total_Bathrooms','Total_porch_SF','MSZoning','Alley','LandContour','LotConfig','Condition1','BldgType','HouseStyle','RoofStyle','Exterior1st','Exterior2nd','MasVnrType','Foundation','Heating','SaleType','SaleCondition','YearBuilt','YearRemodAdd','MasVnrArea','MoSold','YrSold','OverallQual','OverallCond','PavedDrive','PoolArea','PoolQC','Fence','BsmtFinSF1','Electrical','Functional','ExterCond','ExterQual','BsmtQual','BsmtExposure','BsmtFinType1','BsmtUnfSF','HeatingQC','CentralAir','KitchenQual','Fireplaces','FireplaceQu','BedroomAbvGr','KitchenAbvGr','LotShape','GarageType','GarageArea','GarageQual','GarageCond','Neighborhood','hasPool','has2ndFloor','Total_porch_SF')

var_modelo_with_SalePrice = c(var_modelo,'SalePrice')

```

Ahora eliminaremos la columna Id de los datasets para que no intervenga en el modelo y lo recalcularemos con las variables anteriormente comentadas:

```{r}
train_sin_na <- train %>%  na.omit() %>% dplyr::select(-Id)
test_sin_na <- test %>%  na.omit() %>% dplyr::select(-Id)
validation_sin_na <- validation %>%  na.omit() %>% dplyr::select(-Id)

trainTransformed <- predict(preProcValuesTrain, train_sin_na)
testTransformed <- predict(preProcValuesTest, test_sin_na)
validationTransformed <- predict(preProcValuesValidation, validation_sin_na)

modelRegressionTotal <- lm(reformulate(termlabels = var_modelo, response = 'SalePrice') ,data=trainTransformed)

cat('El modelo total usa', length(modelRegressionTotal$coefficients), 'variables ')



#summary( modelRegressionTotal )
#predict(modelRegressionTotal,testTransformed)

```

 A continuación, intentaremos reducir la elevada dimensionalidad del modelo utilizando la libreria Caret y haciendo una regresión de tipo "Step Backward selection", es decir, utilizando el algoritmo que partiendo de todas las variables del modelo vaya creando nuevos modelos quitando cada vez una de las variables que contengan el estimador menos influyente en el modelo hasta converger. Para ello primero relalizamos la codificacion de las varibales categóricas en variables de tipo "dummy":

```{r}
dummiesTrain <- dummyVars(reformulate(termlabels = var_modelo_with_SalePrice ),fullRank = T, data = data.frame(trainTransformed),sep='.')
dummiesTest <- dummyVars(reformulate(termlabels = var_modelo_with_SalePrice ),fullRank = T, data = data.frame(testTransformed),sep='.')
trainTransformedDummies <- predict(dummiesTrain, newdata = trainTransformed)
testTransformedDummies <- predict(dummiesTest, newdata = testTransformed)

```

  El siguiente código teóricamente realiza esa funcionalidad, pero hemos tenido problemas al ejecutarlo debido a que codifica los valores de variables categóricas con espacios de distinta forma que el algoritmo "predict" utilizado en el anterior apartado. Dejamos el código en la práctica para que quede constancia de que por lo menos lo hemos intentado, pero ha dado un montón de problemas y no termina de funcinar correctamente por razones desconocidas:

```{r}
#set.seed(123)
# Set up repeated k-fold cross-validation
#train.control <- trainControl(method = "cv", number = 10)
# Train the model
#step.model <- train(reformulate(termlabels = var_modelo, response = 'SalePrice'), data = #data.frame(trainTransformed)  ,method = "leapBackward", tuneGrid = data.frame(nvmax = #60:200),trControl = train.control,sep = '.')
#step.model$bestTune
#step.model$results
#summary(step.model$finalModel)
#step_coef <- coef(step.model$finalModel, step.model$bestTune$nvmax)
#lm_formula <- as.formula(gsub("[[:space:]]","",str_replace(paste("SalePrice~",paste(names(step_c#oef)[-1] , collapse="+"), sep = ""),'&','.'),))
#modelStepForward <- lm(lm_formula, data = data.frame(trainTransformedDummies))
#summary(step.model)
#prediccion <- predict(step.model$finalModel,data.frame(testTransformedDummies))
#par(mfrow=c(2,2))
#plot(modelStepForward)
#plot(modelStepForward,4,id.n=5)
#plot(modelStepForward,5,id.n=5)
```
Al final, al realizar un predict del anterior modelo, da el siguiente error: Error: C stack usage  7971332 is too close to the limit


Debido al fracaso del anterior modelo, lo intentaremos con una librería distinta que parece que funciona mejor. No obstante, en la ejecución de la misma nos indica que en la selección de variables realizadas siguen existiendo variables correladas.

```{r}
library('olsrr')
modelStepForward <- ols_step_forward_p(modelRegressionTotal)
length(modelStepForward$predictors)
cat('El modelo stepforward usa', length(modelStepForward$model$coefficients), 'variables ')
#plot(modelStepForward)
#ols_plot_resid_fit(modelStepForward$model)
```

 Y por último, utilizando la libreria caret intentarmos obtener una reducción del número de parámetros del modelo mediante una regularización de tipo "lasso":

```{r}

gridLamdas <- expand.grid(alpha = 1, lambda = seq(0.001,0.1,by = 0.0005))
varControl <-caret::trainControl(method="cv", number=10)
lasso_mod <- train(reformulate(termlabels = var_modelo, response = 'SalePrice'), data = data.frame(trainTransformed), method='glmnet', trControl= varControl, tuneGrid=gridLamdas) 
#lasso_mod$bestTune
#min(lasso_mod$results$RMSE)
lassoVarImp <- varImp(lasso_mod,scale=F)
lassoImportance <- lassoVarImp$importance
varsSelected <- length(which(lassoImportance$Overall!=0))
varsNotSelected <- length(which(lassoImportance$Overall==0))
cat(' El modelo de lasso usa', varsSelected, 'variables en el modelo, y rechazo ', varsNotSelected, 'variables.')


#lm_formula_2 <- as.formula(str_replace(paste("SalePrice ~ ",paste(predictors(lasso_mod) , #collapse=" + "), sep = " "),'&','.'))
#modelLasso <- lm(lm_formula_2, data = data.frame(trainTransformedDummies))
#summary(modelLasso)




```

   Como vemos, lasso ha quitado una gran cantidad de regresores, demasiados para nuestro gusto, por lo que no podemos estar seguros de que haya funcionado correctamente.


8. Ajuste, interpretación y diagnosis del modelo de regresión lineal múltiple (2 puntos)

 En primer lugar almacenaremos los valores de las prediccion para la parte de test en 3 variables distintas. El segundo de los modelos da el siguiente warning 'prediction from a rank-deficient fit may be misleading' que no hemos sido capaces de discernir.

```{r}
 
#valoresPredichosModeloCompleto <- predict(modelRegressionTotal,testTransformed)

#valoresPredichosModeloStepForward <- predict(modelStepForward$model,testTransformed)

#valoresPredichosModeloLasso <- predict(lasso_mod,testTransformed)

#vectorCorrelacionesModeloCompleto <- #data.frame(cbind(actuals=testTransformed$SalePrice,predicted=valoresPredichosModeloCompleto))
#correlacionModeloCompleto <- cor(vectorCorrelacionesModeloCompleto)


#vectorCorrelacionesModeloStepForward <- #data.frame(cbind(actuals=testTransformed$SalePrice,predicted=valoresPredichosModeloStepForward))
#correlacionModeloStepForward <- cor(vectorCorrelacionesModeloStepForward)

#vectorCorrelacionesModeloLasso <- #data.frame(cbind(actuals=testTransformed$SalePrice,predicted=valoresPredichosModeloLasso))
#correlacionModeloLasso <- cor(vectorCorrelacionesModeloLasso)

#cat('Correlacion modelo Completo entre predicciones train/test',correlacionModeloCompleto[1,2] )
#cat('Correlacion modelo StepForward entre predicciones #train/test',correlacionModeloStepForward[1,2] )
#cat('Correlacion modelo Lasso entre predicciones train/test',correlacionModeloLasso[1,2] )

```
  
```{r}
# library(DMwR)
#regr.eval(valoresPredichosModeloCompleto,testTransformed$SalePrice)

```

```{r}

#regr.eval(valoresPredichosModeloStepForward,testTransformed$SalePrice)

```

```{r}

# regr.eval(valoresPredichosModeloLasso,testTransformed$SalePrice)

```


  
```{r}
summary(modelRegressionTotal)
```
  
```{r}
summary(modelStepForward$model)
```  
  
```{r}
min(lasso_mod$results$RMSE)
```    
  
```{r}
par(mfrow=c(2,2))
plot(modelRegressionTotal)
```

```{r}
plot(modelRegressionTotal,4,id.n=5)
``` 

```{r}
plot(modelRegressionTotal,5,id.n=5)
```
  

```{r}
par(mfrow=c(2,2))
plot(modelStepForward$model)
```
  

```{r}
plot(modelStepForward$model,4,id.n=5)
``` 
  
```{r}
plot(modelStepForward$model,5,id.n=5)
```   
  
  
  

9. Valoración del profesor (1 punto)
