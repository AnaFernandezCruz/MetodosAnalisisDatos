---
title: "Métodos de Análisis de Datos"
author: "Ana Fernández Cruz, Jesús Gallego Olivas y Miguel Ángel Sánchez Alcázar."
output: html_document
---

A continuación, se detallan los diferentes apartados evaluables en el desarrollo de la práctica y su puntuación. La puntuación completa corresponde al correcto uso, y justificación, de cada una de las técnicas empleadas.

1. Uso de herramienta/s de control de versiones (1 punto)

Para el control de versiones utilizaremos github. El repositorio se encuentra en https://github.com/AnaFernandezCruz/MetodosAnalisisDatos

2. Definición de objetivos (1 punto)

La presente práctica intentará crear un modelo de regresión lineal múltiple para un dataset con las siguientes características. La variable que se intentará inferir será la esperanza de vida


3. Análisis exploratorio inicial (1 punto)

Antes de empezar a realizar la práctica tenemos que cargar los dataset incluidos en la página de Kaggle, unificarlos en un solo dataset y dividirlo en train/test/validación. Para ello:

```{r message=FALSE, warning=FALSE}


library(readr)
library(dplyr)

pathDatos = './Dataset/'
pathLocal = './'
fileTrain = paste(pathDatos,"train.csv",sep="", collapse = NULL)
fileTest = paste(pathDatos,"test.csv",sep="", collapse = NULL)
fileDatosPK = paste(pathDatos,"sample_submission.csv",sep="", collapse = NULL)
fileDatosTrainTest = paste(pathLocal,"train_test.csv",sep="", collapse = NULL)
fileDatosValidacion = paste(pathLocal,"validacion.csv",sep="", collapse = NULL)

borra_columnas_muchos_faltantes = FALSE
borra_columnas_incomodas = FALSE
columnas_borrar_faltantes <- c('FireplaceQu','Fence','Alley','MiscFeature','PoolQC','GarageType','GarageCond','GarageQual','GarageFinish','GarageYrBit','LoftFrontage')
columnas_borrar_incomodas <- c('BsmtFinType1','LowQualFinSF','MasVnrArea','BsmtHalfBath','EnclosedPorch','KitchenAbvGr','MiscVal','PoolArea','ScreenPorch','Utilities','Condition2','RoofMalt','Heating','Street')

    train_kaggle <- read_csv(fileTrain)
    head(train_kaggle)
    
    test_kaggle <- read_csv(fileTest)
    head(test_kaggle)
    
    claves_primarias <- read_csv(fileDatosPK)
    head(claves_primarias)
    
    #Mergeamos el archivo de train y test ya que tienen las mismas columnas.
    
    #test_kaggle <- dplyr::inner_join(x=test_kaggle,y=claves_primarias,by = c('Id','Id'))   
    #full_dataset <- dplyr::union(train_kaggle, test_kaggle)
    #full_dataset_completo <- dplyr::union(train_kaggle, test_kaggle)
    #head(full_dataset)
    
    
    
    ## Completamos test con la columna que falta
    total_test <- merge(test_kaggle,claves_primarias,by="Id")
    
    # Unimos train y test completo
    full_dataset <- rbind(train_kaggle,total_test)
    
    ## Desordenamos todo el dataset
    set.seed(42)
    rows <- sample(nrow(full_dataset))
    df_s <- df[rows, ]

    
    ## Conseguimos el 10% para validacion
    split_validacion <-sort(sample(nrow(full_dataset), nrow(full_dataset)*.1))

    

    if(borra_columnas_muchos_faltantes) {
    
      #full_dataset = subset( full_dataset, select = -columnas_borrar_faltantes)
      df_s <- df_s %>% dplyr::select(-one_of(columnas_borrar_faltantes))
    
    }
  
    if(borra_columnas_incomodas) {
      #full_dataset = subset( full_dataset, select = -columnas_borrar_faltantes)
      df_s <- df_s %>% select(-one_of(columnas_borrar_incomodas))
    }
    
    validacion <-df_s[split_validacion, ]
    if(!file.exists(fileDatosTrainTest)) {
      write.csv(validacion, fileDatosValidacion,row.names=F)
    }
    
    train_test<-df_s[-split_validacion,]
    if(!file.exists(fileDatosTrainTest)) {
      write.csv(train_test, fileDatosTrainTest,row.names=F)
    }
  


train_test <- read_csv(fileDatosTrainTest)
set.seed(55)
dt = sort(sample(nrow(train_test), nrow(train_test)*.7))
train<-train_test[dt,]
test<-train_test[-dt,]

```

  Una vez realiazado el proceso de separación del dataset completo en tres partes (test, train y validación final) realizaremos una primera 


```{r message=FALSE, warning=FALSE}
library(DataExplorer)
introduce(full_dataset_completo)
```


```{r message=FALSE, warning=FALSE}
plot_intro(full_dataset_completo)
```

 Vemos que este gráfico muestra en los valores de "complete rows" un valor del 0%, lo cuál parece indicar un problema con alguna columna en particular.  Lo que observamos es que el valor NA es un valor de algunas de las columnas válido, con lo que habría que corregir esto para estas columnas y volver a hacer el análisis. Supondremos que para estas columnas no existe ningún valor genuinamente en blanco:

   Alley: NA 	No alley access
   BsmtQual: NA	No Basement
   BsmtCond: NA	No Basement
   BsmtExposure: NA	No Basement
   BsmtFinType1: NA	No Basement
   BsmtFinType2:  NA	No Basement
   GarageType: NA	No Garage
   GarageFinish: NA	No Garage
   GarageQual: : NA	No Garage
   GarageCond: : NA	No Garage
   PoolQC:  NA	No Pool
   Fence:  NA	No Fence
   MiscFeature:   NA	None
   
```{r message=FALSE, warning=FALSE}

  columnas_sustitucion_nas <- c('Alley','BsmtQual','BsmtCond','BsmtExposure','BsmtFinType1','BsmtFinType2','GarageType','GarageFinish','GarageQual','GarageCond','PoolQC','Fence','MiscFeature','FireplaceQu')


for (i in columnas_sustitucion_nas) {
 full_dataset <- full_dataset %>%
    dplyr::mutate( !!i
         := replace(!!i,
                   is.na(!!i),
                   'NA'))
 full_dataset_completo <- full_dataset_completo %>%
    dplyr::mutate( !!i
         := replace(!!i,
                   is.na(!!i),
                   'NA'))
 
  train_test <- train_test %>%
    dplyr::mutate( !!i
         := replace(!!i,
                   is.na(!!i),
                   'NA'))
  
  
    train <- train %>%
    dplyr::mutate( !!i
         := replace(!!i,
                   is.na(!!i),
                   'NA'))
  
 
      test <- test  %>%
    dplyr::mutate( !!i
         := replace(!!i,
                   is.na(!!i),
                   'NA'))
  
    
}

```
   

 Las variables que nos encontraremos en el dataset son las siguientes:
  * MSSubClass: la clase de construcción
  * MSZoning: la clasificación general de zonificación
  * LotFrontage: pies lineales de calle conectados a la propiedad
  * LotArea: tamaño del lote en pies cuadrados
  * Street:  tipo de acceso por carretera
  * Alley: tipo de acceso al callejón
  * LotShape: forma general de propiedad
  * LandContour: llanura de la propiedad
  * Utilities:  tipo de utilidades disponibles
  * LotConfig: configuración del lote
  * LandSlope: pendiente de la propiedad
  * Neighborhood: ubicaciones físicas dentro de los límites de la ciudad de Ames
  * Condition1:  Proximidad a la carretera principal o ferrocarril
  * Condition2:  Proximidad a la carretera principal o al ferrocarril (si hay un segundo)
  * BldgType: tipo de vivienda
  * HouseStyle: estilo de vivienda
  * OverallQual: material general y calidad de acabado
  * OverallCond: calificación de condición general
  * YearBuilt: fecha de construcción original
  * YearRemodAdd: fecha de remodelación
  * RoofStyle: tipo de techo
  * RoofMatl: material del techo
  * Exterior1st: cubierta exterior en la casa
  * Exterior2nd: revestimiento exterior de la casa (si hay más de un material)
  * MasVnrType: tipo de chapa de albañilería
  * MasVnrArea: área de revestimiento de mampostería en pies cuadrados
  * ExterQual: calidad del material exterior
  * ExterCond: Condición actual del material en el exterior.
  * Foundation: : tipo de cimiento
  * BsmtQual: altura del sótano
  * BsmtCond: estado general del sótano
  * BsmtExposure: paredes de sótano a nivel de jardín o de salida
  * BsmtFinType1: Calidad del área terminada del sótano
  * BsmtFinSF1: Tipo 1 terminado pies cuadrados
  * BsmtFinType2: Calidad de la segunda área terminada (si está presente)
  * BsmtFinSF2: pies cuadrados terminados tipo 2
  * BsmtUnfSF: pies cuadrados inacabados de área de sótano
  * TotalBsmtSF: pies cuadrados totales del área del sótano
  * Heating:  tipo de calefacción
  * HeatingQC: calidad y condición de calefacción
  * CentralAir: aire acondicionado central
  * Electrical: sistema eléctrico
  * 1stFlrSF: pies cuadrados del primer piso
  * 2ndFlrSF: pies cuadrados del segundo piso
  * LowQualFinSF: pies cuadrados terminados de baja calidad (todos los pisos)
  * GrLivArea: superficie habitable por encima del nivel del suelo (pies cuadrados)
  * BsmtFullBath: baños completos en el sótano
  * BsmtHalfBath: medio baño en el sótano
  * FullBath: baños completos por encima del grado
  * HalfBath: medio baño por encima del grado
  * Bedroom: número de dormitorios por encima del nivel del sótano
  * Kitchen número de cocinas
  * KitchenQual: calidad de cocina
  * TotRmsAbvGrd: total de habitaciones por encima del grado (no incluye baños)
  * Functional: calificación de funcionalidad doméstica 
  * Fireplaces: : número de chimeneas
  * FireplaceQu: calidad de chimenea
  * GarageType: ubicación del garaje
  * GarageYrBlt: año en que se construyó el garaje
  * GarageFinish: acabado interior del garaje
  * GarageCars: tamaño del garaje en la capacidad del automóvil
  * GarageArea: tamaño del garaje en pies cuadrados
  * GarageQual: calidad de garaje
  * GarageCond: condición del garaje
  * PavedDrive: entrada pavimentada
  * WoodDeckSF: área de cubierta de madera en pies cuadrados
  * OpenPorchSF: área de porche abierto en pies cuadrados
  * Porche cerrado: área de porche cerrado en pies cuadrados
  * EnclosedPorch:  área de porche de tres estaciones en pies cuadrados
  * ScreenPorch: área del porche de la pantalla en pies cuadrados
  * PoolArea: área de la piscina en pies cuadrados
  * PoolQC: calidad de la piscina
  * Fence: calidad de la cerca
  * MiscFeature: características varias no cubiertas en otras categorías
  * MiscVal: $ Valor de la característica miscelánea
  * MoSold: Mes vendido
  * YrSold: año vendido
  * SaleType: tipo de venta
  * SaleCondition: condición de venta


```{r message=FALSE, warning=FALSE}
library(skimr)
library(pander)
skim(full_dataset_completo)  %>% pander()
```

```{r message=FALSE, warning=FALSE}
library(VIM)
aggr(train)
```


```{r message=FALSE, warning=FALSE}
missing_data <- plot_missing(full_dataset_completo)
```


```{r message=FALSE, warning=FALSE}
# DataExplorer::create_report(datosOriginales) 
plot_bar(full_dataset_completo)
```


```{r message=FALSE, warning=FALSE}
test %>% plot_histogram()
```

```{r message=FALSE, warning=FALSE}
test %>% plot_qq(sampled_rows = 1000L)
```


```{r message=FALSE, warning=FALSE}
library(ggplot2)
splitDataset <- split_columns(full_dataset_completo, binary_as_factor = FALSE)
plot_correlation(na.omit(splitDataset$continuous), type = "c" ,maxcat = 5L,theme_config = list(legend.position = "bottom", axis.text.x =element_text(angle = 90)))
```

```{r message=FALSE, warning=FALSE}

var_discretas <- c('BsmtFullBath','BsmtHalfBath','FullBath','HalfBath','BedroomAbvGr','KitchenAbvGr','TotRmsAbvGrd','Fireplaces','GarageCars','GarageYrBlt','YearBuilt','YearRemodAdd','YrSold','MoSold')

var_continuas <- c('LotFrontage','LotArea','MasVnrArea','BsmtFinSF1','BsmtFinSF2','BsmtUnfSF','TotalBsmtSF','1stFlrSF','2ndFlrSF','LowQualFinSF','GrLivArea','GarageArea','WoodDeckSF','OpenPorchSF','EnclosedPorch', '3SsnPorch','ScreenPorch','PoolArea','MiscVal','SalePrice')

var_ordinales <- c('LotShape','Utilities','LandSlope','OverallQual','OverallCond','ExterQual','ExterCond','BsmtQual','BsmtCond','BsmtExposure','BsmtFinType1','BsmtFinType2','HeatingQC','CentralAir','Electrical','KitchenQual','Functional','FireplaceQu','GarageFinish','GarageQual','GarageCond','PavedDrive','PoolQC','Fence')

var_nominales <- c('MSSubClass','MSZoning','Street','Alley','LandContour','LotConfig','Neighborhood','Condition1','Condition2','BldgType','HouseStyle','RoofStyle','RoofMatl','Exterior1st',
'Exterior2nd','MasVnrType','Foundation','Heating','GarageType','MiscFeature', 'SaleType','SaleCondition')



library(corrr)
corrmatrix <-corrr::correlate(na.omit(full_dataset_completo %>% dplyr::select(var_continuas)))
corrmatrix2 <-corrr::correlate(na.omit(full_dataset_completo %>% dplyr::select(var_discretas)))

rplot(corrmatrix, legend = TRUE, shape = 16)
network_plot(corrmatrix)

```

```{r message=FALSE, warning=FALSE}


```

```{r message=FALSE, warning=FALSE}
outlier_values <- boxplot.stats(full_dataset_completo$SalePrice )$out
boxplot(full_dataset_completo$SalePrice, main="Pressure Height", boxwex=0.1)
mtext(paste("Outliers: ", paste(outlier_values, collapse=", ")), cex=0.6)
outlier_values

```

4. Detección, tratamiento e imputación de datos faltantes (1 punto)
5. Transformaciones de variables cuantitativas (1 punto)

```{r}

#MSSubClass: 
leveslMSubClass <- c(
"1-STORY 1946 & NEWER ALL STYLES",
"1-STORY 1945 & OLDER",
"1-STORY W/FINISHED ATTIC ALL AGES",
"1-1/2 STORY - UNFINISHED ALL AGES",
"50	1-1/2 STORY FINISHED ALL AGES",
"60	2-STORY 1946 & NEWER",
"2-STORY 1945 & OLDER",
"2-1/2 STORY ALL AGES",
"SPLIT OR MULTI-LEVEL",
"85	SPLIT FOYER",
"DUPLEX - ALL STYLES AND AGES",
"1-STORY PUD (Planned Unit Development) - 1946 & NEWER",
"1-1/2 STORY PUD - ALL AGES",
"160	2-STORY PUD - 1946 & NEWER",
"PUD - MULTILEVEL - INCL SPLIT LEV/FOYER",
"2 FAMILY CONVERSION - ALL STYLES AND AGES"
)

#OverallQual, OverallCond (dejarlas como estan)
levesl1_10 <- c("Very Poor","Poor","Fair","Below Average","Average","Above Average","Good","Very Good","Excellent","Very Excellent")

#ExterQual , ExterCond , HeatingQC, KitchenQual,GarageQual,GarageCond
return_position1_5 <- function(elements) {
    levesl1_5 <- c('Po','Fa','TA','Gd','Ex')
    pos <- match(elements,levesl1_5)
    elem <- which(levesl1_5 %in% elements)
    return(levesl1_5[elem])
}


#BsmtQual,BsmtCond,FireplaceQu
return_position1_6 <- function(elements) {
    levesl1_6 <- c('NA','Po','Fa','TA','Gd','Ex')
    pos <- match(elements,levesl1_6)
    elem <- which(levesl1_6 %in% elements)
    return(levesl1_6[elem])
}


#BsmtExposure
return_position1_5_B <- function(elements) {
    levesl1_5_B <- c('NA','No','Mn','Av','Gd')
    pos <- match(elements,levesl1_5_B)
    elem <- which(levesl1_5_B %in% elements)
    return(levesl1_5_B[elem])
}


#BsmtFinType1 , BsmtFinType2
return_position1_7 <- function(elements) {
    levesl1_7 <- c('NA','Unf','LwQ','Rec','BLQ','ALQ','GLQ')
    pos <- match(elements,levesl1_7)
    elem <- which(levesl1_7 %in% elements)
    return(levesl1_7[elem])
}

#CentralAir
levesl_2 <- c('N','Y')  

#GarageFinish
return_levels_garage <- function(elements) {
    levels_garage <-c('NA','Unf','RFn','Fin')
    pos <- match(elements,levels_garage)
    elem <- which(levels_garage %in% elements)
    return(levels_garage[elem])
}


# PoolQC
return_levesl_poolQC <- function(elements) {
    levesl_poolQC <- -c('NA','Fa','TA','Gd','Ex')
    pos <- match(elements,levesl_poolQC)
    elem <- which(llevesl_poolQC %in% elements)
    return(levesl_poolQC[elem])
}


library(forcats)

      #OverallCond
      train <- train %>% dplyr::mutate( ExterQual:=fct_relevel(ExterQual,return_position1_5))
      test <- test %>% dplyr::mutate( ExterQual:=fct_relevel(ExterQual,return_position1_5))
      #ExterCond , 
      train <- train %>% dplyr::mutate( ExterCond := fct_relevel(ExterCond,return_position1_5))
      test <- test %>% dplyr::mutate( ExterCond := fct_relevel(ExterCond,return_position1_5))
      #HeatingQC, 
      train <- train %>% dplyr::mutate( HeatingQC := fct_relevel(HeatingQC,return_position1_5))
      test <-  test %>% dplyr::mutate( HeatingQC := fct_relevel(HeatingQC,return_position1_5))
      #KitchenQual,
      train <- train %>% dplyr::mutate( KitchenQual := fct_relevel(KitchenQual,return_position1_5))
      test <-  test %>% dplyr::mutate( KitchenQual := fct_relevel(KitchenQual,return_position1_5))
      #GarageQual,
      train <- train %>% dplyr::mutate( GarageQual := fct_relevel(GarageQual,return_position1_5))
      test <-  test %>% dplyr::mutate( GarageQual := fct_relevel(GarageQual,return_position1_5))
      #GarageCond
      train <- train %>% dplyr::mutate( GarageCond := fct_relevel(GarageCond,return_position1_5))
      test <-  test %>% dplyr::mutate( GarageCond := fct_relevel(GarageCond,return_position1_5))
      #BsmtQual
      train <- train %>% dplyr::mutate( BsmtQual := fct_relevel(BsmtQual,return_position1_6))
      test <-  test %>% dplyr::mutate( BsmtQual := fct_relevel(BsmtQual,return_position1_6))
      #BsmtCond,
      train <- train %>% dplyr::mutate( BsmtCond := fct_relevel(BsmtCond,return_position1_6))
      test <- test %>% dplyr::mutate( BsmtCond := fct_relevel(BsmtCond,return_position1_6))
      #FireplaceQu
      train <- train %>% dplyr::mutate(FireplaceQu := fct_relevel(FireplaceQu,return_position1_6))
      test <-  test %>% dplyr::mutate(FireplaceQu := fct_relevel(FireplaceQu,return_position1_6))
      #BsmtExposure
      train <- train %>% dplyr::mutate( BsmtExposure := fct_relevel(BsmtExposure,return_position1_5_B))
      test <-  test %>% dplyr::mutate( BsmtExposure := fct_relevel(BsmtExposure,return_position1_5_B))
      #BsmtFinType1 
      train <- train %>% dplyr::mutate( BsmtFinType1 := fct_relevel(BsmtFinType1,return_position1_7))
      test <-  test %>% dplyr::mutate( BsmtFinType1 := fct_relevel(BsmtFinType1,return_position1_7))
      #BsmtFinType2
      train <- train %>% dplyr::mutate( BsmtFinType1 := fct_relevel(BsmtFinType2,return_position1_7))
      test <-  test %>% dplyr::mutate( BsmtFinType1 := fct_relevel(BsmtFinType2,return_position1_7))
     #GarageFinish
      #train <- train %>% dplyr::mutate( GarageFinish := fct_relevel(GarageFinish,return_levels_garage))
      #test <-  test %>% dplyr::mutate( GarageFinish := fct_relevel(GarageFinish,return_levels_garage))
      # PoolQC
      #train <- train %>% dplyr::mutate( PoolQC := fct_relevel(PoolQC,return_levesl_poolQC))
      #test <-  test %>% dplyr::mutate( PoolQC := fct_relevel(PoolQC,return_levesl_poolQC))

      
      
  #for(i in var_nominales) {
  #   train <- train %>% dplyr::mutate( !!i := factor(!!i))
  #}
      
      
# YearBuilt: a ver que hacemos con esta
# YearRemodAdd: y esta lo mismo
      

```



6. Procesado de variables cualitativas (1 punto)



7. Selección de variables (1 punto)
8. Ajuste, interpretación y diagnosis del modelo de regresión lineal múltiple (2 puntos)
9. Valoración del profesor (1 punto)
